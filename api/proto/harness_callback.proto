syntax = "proto3";
package gibson.harness;
option go_package = "github.com/zero-day-ai/sdk/api/gen/proto";

// HarnessCallbackService provides the harness interface for agents executing in standalone mode.
// The SDK's CallbackHarness forwards all harness operations to the orchestrator via this service.
service HarnessCallbackService {
    // LLM Operations
    rpc LLMComplete(LLMCompleteRequest) returns (LLMCompleteResponse);
    rpc LLMCompleteWithTools(LLMCompleteWithToolsRequest) returns (LLMCompleteResponse);
    rpc LLMCompleteStructured(LLMCompleteStructuredRequest) returns (LLMCompleteStructuredResponse);
    rpc LLMStream(LLMStreamRequest) returns (stream LLMStreamChunk);

    // Tool Operations
    rpc CallTool(CallToolRequest) returns (CallToolResponse);
    rpc ListTools(ListToolsRequest) returns (ListToolsResponse);

    // Plugin Operations
    rpc QueryPlugin(QueryPluginRequest) returns (QueryPluginResponse);
    rpc ListPlugins(ListPluginsRequest) returns (ListPluginsResponse);

    // Agent Operations
    rpc DelegateToAgent(DelegateToAgentRequest) returns (DelegateToAgentResponse);
    rpc ListAgents(ListAgentsRequest) returns (ListAgentsResponse);

    // Finding Operations
    rpc SubmitFinding(SubmitFindingRequest) returns (SubmitFindingResponse);
    rpc GetFindings(GetFindingsRequest) returns (GetFindingsResponse);

    // Memory Operations
    rpc MemoryGet(MemoryGetRequest) returns (MemoryGetResponse);
    rpc MemorySet(MemorySetRequest) returns (MemorySetResponse);
    rpc MemoryDelete(MemoryDeleteRequest) returns (MemoryDeleteResponse);
    rpc MemoryList(MemoryListRequest) returns (MemoryListResponse);

    // Mission Memory operations
    rpc MissionMemorySearch(MissionMemorySearchRequest) returns (MissionMemorySearchResponse);
    rpc MissionMemoryHistory(MissionMemoryHistoryRequest) returns (MissionMemoryHistoryResponse);
    rpc MissionMemoryGetPreviousRunValue(MissionMemoryGetPreviousRunValueRequest) returns (MissionMemoryGetPreviousRunValueResponse);
    rpc MissionMemoryGetValueHistory(MissionMemoryGetValueHistoryRequest) returns (MissionMemoryGetValueHistoryResponse);
    rpc MissionMemoryContinuityMode(MissionMemoryContinuityModeRequest) returns (MissionMemoryContinuityModeResponse);

    // Long-Term Memory operations
    rpc LongTermMemoryStore(LongTermMemoryStoreRequest) returns (LongTermMemoryStoreResponse);
    rpc LongTermMemorySearch(LongTermMemorySearchRequest) returns (LongTermMemorySearchResponse);
    rpc LongTermMemoryDelete(LongTermMemoryDeleteRequest) returns (LongTermMemoryDeleteResponse);

    // GraphRAG Query Operations
    rpc GraphRAGQuery(GraphRAGQueryRequest) returns (GraphRAGQueryResponse);
    rpc FindSimilarAttacks(FindSimilarAttacksRequest) returns (FindSimilarAttacksResponse);
    rpc FindSimilarFindings(FindSimilarFindingsRequest) returns (FindSimilarFindingsResponse);
    rpc GetAttackChains(GetAttackChainsRequest) returns (GetAttackChainsResponse);
    rpc GetRelatedFindings(GetRelatedFindingsRequest) returns (GetRelatedFindingsResponse);

    // GraphRAG Storage Operations
    rpc StoreGraphNode(StoreGraphNodeRequest) returns (StoreGraphNodeResponse);
    rpc CreateGraphRelationship(CreateGraphRelationshipRequest) returns (CreateGraphRelationshipResponse);
    rpc StoreGraphBatch(StoreGraphBatchRequest) returns (StoreGraphBatchResponse);
    rpc TraverseGraph(TraverseGraphRequest) returns (TraverseGraphResponse);
    rpc GraphRAGHealth(GraphRAGHealthRequest) returns (GraphRAGHealthResponse);

    // Planning Operations
    rpc GetPlanContext(GetPlanContextRequest) returns (GetPlanContextResponse);
    rpc ReportStepHints(ReportStepHintsRequest) returns (ReportStepHintsResponse);

    // Distributed Tracing Operations
    rpc RecordSpan(RecordSpanRequest) returns (RecordSpanResponse);
    rpc RecordSpans(RecordSpansRequest) returns (RecordSpansResponse);

    // Credential Operations
    rpc GetCredential(GetCredentialRequest) returns (GetCredentialResponse);

    // Taxonomy Operations
    rpc GetTaxonomySchema(GetTaxonomySchemaRequest) returns (GetTaxonomySchemaResponse);
    rpc GenerateNodeID(GenerateNodeIDRequest) returns (GenerateNodeIDResponse);
    rpc ValidateFinding(ValidateFindingRequest) returns (ValidationResponse);
    rpc ValidateGraphNode(ValidateGraphNodeRequest) returns (ValidationResponse);
    rpc ValidateRelationship(ValidateRelationshipRequest) returns (ValidationResponse);
}

// ============================================================================
// Common Types
// ============================================================================

// Error represents an error response from a callback operation.
message HarnessError {
    string code = 1;
    string message = 2;
    bool retryable = 3;
}

// HealthStatus represents the health status of a service.
message HarnessHealthStatus {
    string state = 1;      // healthy, degraded, unhealthy
    string message = 2;
    int64 checked_at = 3;  // Unix timestamp in milliseconds
}

message ContextInfo {
    string task_id = 1;
    string agent_name = 2;
    string trace_id = 3;
    string span_id = 4;
    string mission_id = 5;
}

message TokenUsage {
    int32 input_tokens = 1;
    int32 output_tokens = 2;
    int32 total_tokens = 3;
}

message LLMMessage {
    string role = 1;  // system, user, assistant, tool
    string content = 2;
    repeated ToolCall tool_calls = 3;
    repeated ToolResult tool_results = 4;
    string name = 5;  // For tool messages
}

message ToolCall {
    string id = 1;
    string name = 2;
    string arguments = 3;  // JSON string
}

message ToolResult {
    string tool_call_id = 1;
    string content = 2;
    bool is_error = 3;
}

message ToolDef {
    string name = 1;
    string description = 2;
    string parameters_json = 3;  // JSON schema
}

// ============================================================================
// LLM Operations
// ============================================================================

message LLMCompleteRequest {
    ContextInfo context = 1;
    string slot = 2;
    repeated LLMMessage messages = 3;

    // Completion options
    optional double temperature = 4;
    optional int32 max_tokens = 5;
    optional double top_p = 6;
    repeated string stop = 7;
}

message LLMCompleteWithToolsRequest {
    ContextInfo context = 1;
    string slot = 2;
    repeated LLMMessage messages = 3;
    repeated ToolDef tools = 4;
}

message LLMCompleteStructuredRequest {
    ContextInfo context = 1;
    string slot = 2;
    repeated LLMMessage messages = 3;
    string schema_json = 4;  // JSON-encoded schema (Go struct as JSON)
}

message LLMCompleteStructuredResponse {
    string result_json = 1;  // JSON-encoded structured result
    TokenUsage usage = 2;
    HarnessError error = 3;
}

message LLMCompleteResponse {
    string content = 1;
    repeated ToolCall tool_calls = 2;
    string finish_reason = 3;
    TokenUsage usage = 4;
    HarnessError error = 5;
}

message LLMStreamRequest {
    ContextInfo context = 1;
    string slot = 2;
    repeated LLMMessage messages = 3;

    // Completion options
    optional double temperature = 4;
    optional int32 max_tokens = 5;
    optional double top_p = 6;
    repeated string stop = 7;
}

message LLMStreamChunk {
    string delta = 1;
    repeated ToolCall tool_calls = 2;
    string finish_reason = 3;
    TokenUsage usage = 4;
    HarnessError error = 5;
}

// ============================================================================
// Tool Operations
// ============================================================================

message CallToolRequest {
    ContextInfo context = 1;
    string name = 2;
    string input_json = 3;  // JSON-encoded map[string]any
}

message CallToolResponse {
    string output_json = 1;  // JSON-encoded map[string]any
    HarnessError error = 2;
}

message ListToolsRequest {
    ContextInfo context = 1;
}

message ListToolsResponse {
    repeated HarnessToolDescriptor tools = 1;
    HarnessError error = 2;
}

message HarnessToolDescriptor {
    string name = 1;
    string description = 2;
    string schema_json = 3;  // JSON-encoded input schema (legacy, use input_schema for structured)
    string output_schema_json = 4;  // JSON-encoded output schema with taxonomy
    // Structured schemas with full taxonomy support (preferred over JSON)
    JSONSchemaNode input_schema = 5;
    JSONSchemaNode output_schema = 6;
}

// JSONSchemaNode represents a JSON Schema node with taxonomy support.
// Used for structured schema transmission that preserves taxonomy mappings.
message JSONSchemaNode {
    string type = 1;  // "string", "number", "integer", "boolean", "array", "object"
    string description = 2;
    map<string, JSONSchemaNode> properties = 3;
    repeated string required = 4;
    JSONSchemaNode items = 5;  // For array types
    repeated string enum_values = 6;
    string format = 7;
    optional double minimum = 8;
    optional double maximum = 9;
    optional int32 min_length = 10;
    optional int32 max_length = 11;
    optional int32 min_items = 12;
    optional int32 max_items = 13;
    optional string pattern = 14;
    optional string default_value = 15;
    bool nullable = 16;
    TaxonomyMapping taxonomy = 17;  // Taxonomy mapping for knowledge graph extraction
}

// TaxonomyMapping defines how tool output maps to knowledge graph nodes.
// Uses deterministic ID generation based on identifying properties instead of templates.
message TaxonomyMapping {
    string node_type = 1;  // e.g., "host", "port", "finding"
    map<string, string> identifying_properties = 2;  // Property name -> JSONPath expression for ID generation
    repeated PropertyMapping properties = 3;
    repeated RelationshipMapping relationships = 4;
}

// PropertyMapping maps a source field to a target property.
message PropertyMapping {
    string source = 1;  // JSONPath expression, e.g., "$.ip"
    string target = 2;  // Property name, e.g., "ip_address"
    string default_value = 3;  // Default value if source is missing
    string transform = 4;  // Transformation function (e.g., "lowercase", "trim")
}

// NodeReference identifies a node by type and property mappings.
// Use type="self" to reference the current node being mapped.
message NodeReference {
    string type = 1;  // Node type (e.g., "host", "port") or "self" for current node
    map<string, string> properties = 2;  // Identifying property name -> JSONPath expression
}

// RelationshipMapping defines relationships between nodes using typed references.
message RelationshipMapping {
    string type = 1;  // e.g., "HAS_PORT", "DISCOVERED_BY"
    NodeReference from = 2;  // Source node reference (use type="self" for current node)
    NodeReference to = 3;  // Target node reference
    string condition = 4;  // Optional condition for creating this relationship
    repeated PropertyMapping rel_properties = 5;  // Property mappings for the relationship edge
}

// ============================================================================
// Plugin Operations
// ============================================================================

message QueryPluginRequest {
    ContextInfo context = 1;
    string name = 2;
    string method = 3;
    string params_json = 4;  // JSON-encoded map[string]any
}

message QueryPluginResponse {
    string result_json = 1;  // JSON-encoded any
    HarnessError error = 2;
}

message ListPluginsRequest {
    ContextInfo context = 1;
}

message ListPluginsResponse {
    repeated HarnessPluginDescriptor plugins = 1;
    HarnessError error = 2;
}

message HarnessPluginDescriptor {
    string name = 1;
    string description = 2;
    string version = 3;
    repeated string methods = 4;
}

// ============================================================================
// Agent Operations
// ============================================================================

message DelegateToAgentRequest {
    ContextInfo context = 1;
    string name = 2;
    string task_json = 3;  // JSON-encoded agent.Task
}

message DelegateToAgentResponse {
    string result_json = 1;  // JSON-encoded agent.Result
    HarnessError error = 2;
}

message ListAgentsRequest {
    ContextInfo context = 1;
}

message ListAgentsResponse {
    repeated HarnessAgentDescriptor agents = 1;
    HarnessError error = 2;
}

message HarnessAgentDescriptor {
    string name = 1;
    string version = 2;
    string description = 3;
    repeated string capabilities = 4;
    repeated string target_types = 5;
    repeated string technique_types = 6;
}

// ============================================================================
// Finding Operations
// ============================================================================

message SubmitFindingRequest {
    ContextInfo context = 1;
    string finding_json = 2;  // JSON-encoded agent.Finding
}

message SubmitFindingResponse {
    HarnessError error = 1;
}

message GetFindingsRequest {
    ContextInfo context = 1;
    string filter_json = 2;  // JSON-encoded agent.FindingFilter
}

message GetFindingsResponse {
    repeated string findings_json = 1;  // JSON-encoded []agent.Finding
    HarnessError error = 2;
}

// ============================================================================
// Memory Operations
// ============================================================================

// MemoryTier specifies which memory tier to use for an operation.
enum MemoryTier {
    MEMORY_TIER_UNSPECIFIED = 0;  // Default to WORKING for backward compatibility
    MEMORY_TIER_WORKING = 1;      // Ephemeral in-memory
    MEMORY_TIER_MISSION = 2;      // Persistent per-mission with FTS
    MEMORY_TIER_LONG_TERM = 3;    // Vector-based semantic storage
}

message MemoryGetRequest {
    ContextInfo context = 1;
    string key = 2;
    MemoryTier tier = 3;
}

message MemoryGetResponse {
    string value_json = 1;  // JSON-encoded any
    bool found = 2;
    HarnessError error = 3;
    string metadata_json = 4;
    string created_at = 5;
    string updated_at = 6;
}

message MemorySetRequest {
    ContextInfo context = 1;
    string key = 2;
    string value_json = 3;  // JSON-encoded any
    MemoryTier tier = 4;
    string metadata_json = 5;
}

message MemorySetResponse {
    HarnessError error = 1;
}

message MemoryDeleteRequest {
    ContextInfo context = 1;
    string key = 2;
    MemoryTier tier = 3;
}

message MemoryDeleteResponse {
    HarnessError error = 1;
}

message MemoryListRequest {
    ContextInfo context = 1;
    string prefix = 2;
    MemoryTier tier = 3;
}

message MemoryListResponse {
    repeated string keys = 1;
    HarnessError error = 2;
}

// ============================================================================
// Mission Memory Operations
// ============================================================================

message MissionMemorySearchRequest {
    ContextInfo context = 1;
    string query = 2;
    int32 limit = 3;
}

message MissionMemorySearchResponse {
    repeated MissionMemoryResult results = 1;
    HarnessError error = 2;
}

message MissionMemoryResult {
    string key = 1;
    string value_json = 2;
    string metadata_json = 3;
    double score = 4;
    string created_at = 5;
    string updated_at = 6;
}

message MissionMemoryHistoryRequest {
    ContextInfo context = 1;
    int32 limit = 2;
}

message MissionMemoryHistoryResponse {
    repeated MissionMemoryItem items = 1;
    HarnessError error = 2;
}

message MissionMemoryItem {
    string key = 1;
    string value_json = 2;
    string metadata_json = 3;
    string created_at = 4;
    string updated_at = 5;
}

message MissionMemoryGetPreviousRunValueRequest {
    ContextInfo context = 1;
    string key = 2;
}

message MissionMemoryGetPreviousRunValueResponse {
    string value_json = 1;
    bool found = 2;
    HarnessError error = 3;
}

message MissionMemoryGetValueHistoryRequest {
    ContextInfo context = 1;
    string key = 2;
}

message MissionMemoryGetValueHistoryResponse {
    repeated HistoricalValueItem values = 1;
    HarnessError error = 2;
}

message HistoricalValueItem {
    string value_json = 1;
    int32 run_number = 2;
    string mission_id = 3;
    string stored_at = 4;
}

message MissionMemoryContinuityModeRequest {
    ContextInfo context = 1;
}

message MissionMemoryContinuityModeResponse {
    string mode = 1;
    HarnessError error = 2;
}

// ============================================================================
// Long-Term Memory Operations
// ============================================================================

message LongTermMemoryStoreRequest {
    ContextInfo context = 1;
    string content = 2;
    string metadata_json = 3;
}

message LongTermMemoryStoreResponse {
    string id = 1;
    HarnessError error = 2;
}

message LongTermMemorySearchRequest {
    ContextInfo context = 1;
    string query = 2;
    int32 top_k = 3;
    string filters_json = 4;
}

message LongTermMemorySearchResponse {
    repeated LongTermMemoryResult results = 1;
    HarnessError error = 2;
}

message LongTermMemoryResult {
    string id = 1;
    string content = 2;
    string metadata_json = 3;
    double score = 4;
    string created_at = 5;
}

message LongTermMemoryDeleteRequest {
    ContextInfo context = 1;
    string id = 2;
}

message LongTermMemoryDeleteResponse {
    HarnessError error = 1;
}

// ============================================================================
// GraphRAG Query Operations
// ============================================================================

message GraphRAGQueryRequest {
    ContextInfo context = 1;
    string query_json = 2;  // JSON-encoded graphrag.Query
}

message GraphRAGQueryResponse {
    repeated GraphRAGResult results = 1;
    HarnessError error = 2;
}

message GraphRAGResult {
    GraphNode node = 1;
    double score = 2;
    double vector_score = 3;
    double graph_score = 4;
    repeated string path = 5;
    int32 distance = 6;
}

message GraphNode {
    string id = 1;
    string type = 2;
    string properties_json = 3;  // JSON-encoded map[string]any
    string content = 4;
    string mission_id = 5;
    string agent_name = 6;
    int64 created_at = 7;  // Unix timestamp
    int64 updated_at = 8;  // Unix timestamp
}

message FindSimilarAttacksRequest {
    ContextInfo context = 1;
    string content = 2;
    int32 top_k = 3;
}

message FindSimilarAttacksResponse {
    repeated AttackPattern attacks = 1;
    HarnessError error = 2;
}

message AttackPattern {
    string technique_id = 1;
    string name = 2;
    string description = 3;
    repeated string tactics = 4;
    repeated string platforms = 5;
    double similarity = 6;
}

message FindSimilarFindingsRequest {
    ContextInfo context = 1;
    string finding_id = 2;
    int32 top_k = 3;
}

message FindSimilarFindingsResponse {
    repeated FindingNode findings = 1;
    HarnessError error = 2;
}

message FindingNode {
    string id = 1;
    string title = 2;
    string description = 3;
    string severity = 4;
    string category = 5;
    double confidence = 6;
    double similarity = 7;
}

message GetAttackChainsRequest {
    ContextInfo context = 1;
    string technique_id = 2;
    int32 max_depth = 3;
}

message GetAttackChainsResponse {
    repeated AttackChain chains = 1;
    HarnessError error = 2;
}

message AttackChain {
    string id = 1;
    string name = 2;
    string severity = 3;
    repeated AttackStep steps = 4;
}

message AttackStep {
    int32 order = 1;
    string technique_id = 2;
    string node_id = 3;
    string description = 4;
    double confidence = 5;
}

message GetRelatedFindingsRequest {
    ContextInfo context = 1;
    string finding_id = 2;
}

message GetRelatedFindingsResponse {
    repeated FindingNode findings = 1;
    HarnessError error = 2;
}

// ============================================================================
// GraphRAG Storage Operations
// ============================================================================

message StoreGraphNodeRequest {
    ContextInfo context = 1;
    GraphNode node = 2;
}

message StoreGraphNodeResponse {
    string node_id = 1;
    HarnessError error = 2;
}

message CreateGraphRelationshipRequest {
    ContextInfo context = 1;
    Relationship relationship = 2;
}

message CreateGraphRelationshipResponse {
    HarnessError error = 1;
}

message Relationship {
    string from_id = 1;
    string to_id = 2;
    string type = 3;
    string properties_json = 4;  // JSON-encoded map[string]any
    bool bidirectional = 5;
}

message StoreGraphBatchRequest {
    ContextInfo context = 1;
    repeated GraphNode nodes = 2;
    repeated Relationship relationships = 3;
}

message StoreGraphBatchResponse {
    repeated string node_ids = 1;
    HarnessError error = 2;
}

message TraverseGraphRequest {
    ContextInfo context = 1;
    string start_node_id = 2;
    TraversalOptions options = 3;
}

message TraverseGraphResponse {
    repeated TraversalResult results = 1;
    HarnessError error = 2;
}

message TraversalOptions {
    int32 max_depth = 1;
    repeated string relationship_types = 2;
    repeated string node_types = 3;
    string direction = 4;  // outgoing, incoming, both
}

message TraversalResult {
    GraphNode node = 1;
    repeated string path = 2;
    int32 distance = 3;
}

message GraphRAGHealthRequest {
    ContextInfo context = 1;
}

message GraphRAGHealthResponse {
    HarnessHealthStatus status = 1;
}

// ============================================================================
// Planning Operations
// ============================================================================

message GetPlanContextRequest {
    ContextInfo context = 1;
}

message GetPlanContextResponse {
    PlanContext plan_context = 1;
    HarnessError error = 2;
}

message PlanContext {
    int32 current_step_index = 1;
    int32 total_steps = 2;
    repeated string remaining_steps = 3;
    int32 step_budget = 4;
    int32 mission_budget_remaining = 5;
}

message ReportStepHintsRequest {
    ContextInfo context = 1;
    StepHints hints = 2;
}

message ReportStepHintsResponse {
    HarnessError error = 1;
}

message StepHints {
    double confidence = 1;
    repeated string suggested_next = 2;
    string replan_reason = 3;
    repeated string key_findings = 4;
}

// ============================================================================
// Distributed Tracing Operations
// ============================================================================

// SpanKind represents the role of a span in a distributed trace.
enum SpanKind {
    SPAN_KIND_UNSPECIFIED = 0;
    SPAN_KIND_INTERNAL = 1;
    SPAN_KIND_SERVER = 2;
    SPAN_KIND_CLIENT = 3;
    SPAN_KIND_PRODUCER = 4;
    SPAN_KIND_CONSUMER = 5;
}

// StatusCode represents the status of a span.
enum StatusCode {
    STATUS_CODE_UNSET = 0;
    STATUS_CODE_OK = 1;
    STATUS_CODE_ERROR = 2;
}

// AnyValue represents a dynamically typed value used in attributes.
message AnyValue {
    oneof value {
        string string_value = 1;
        bool bool_value = 2;
        int64 int_value = 3;
        double double_value = 4;
        bytes bytes_value = 5;
    }
}

// KeyValue represents a key-value pair used in span attributes.
message KeyValue {
    string key = 1;
    AnyValue value = 2;
}

// SpanEvent represents a single event within a span.
message SpanEvent {
    string name = 1;
    int64 time_unix_nano = 2;
    repeated KeyValue attributes = 3;
}

// Span represents a single span in a distributed trace.
message Span {
    string trace_id = 1;
    string span_id = 2;
    string parent_span_id = 3;
    int64 start_time_unix_nano = 4;
    int64 end_time_unix_nano = 5;
    string name = 6;
    SpanKind kind = 7;
    StatusCode status_code = 8;
    string status_message = 9;
    repeated KeyValue attributes = 10;
    repeated SpanEvent events = 11;
}

message RecordSpanRequest {
    ContextInfo context = 1;
    Span span = 2;
}

message RecordSpanResponse {
    HarnessError error = 1;
}

message RecordSpansRequest {
    ContextInfo context = 1;
    repeated Span spans = 2;
}

message RecordSpansResponse {
    HarnessError error = 1;
}

// ============================================================================
// Credential Operations
// ============================================================================

// CredentialType represents the type of credential.
enum CredentialType {
    CREDENTIAL_TYPE_UNSPECIFIED = 0;
    CREDENTIAL_TYPE_API_KEY = 1;
    CREDENTIAL_TYPE_BEARER = 2;
    CREDENTIAL_TYPE_BASIC = 3;
    CREDENTIAL_TYPE_OAUTH = 4;
    CREDENTIAL_TYPE_CUSTOM = 5;
}

message GetCredentialRequest {
    ContextInfo context = 1;
    string name = 2;  // Credential name (e.g., "hackerone-api")
}

message GetCredentialResponse {
    Credential credential = 1;
    HarnessError error = 2;
}

message Credential {
    string name = 1;
    CredentialType type = 2;
    string secret = 3;           // The decrypted secret value
    string username = 4;         // For BASIC auth credentials
    string metadata_json = 5;    // JSON-encoded additional metadata
}

// ============================================================================
// Taxonomy Operations
// ============================================================================

message GetTaxonomySchemaRequest {
    ContextInfo context = 1;
}

message GetTaxonomySchemaResponse {
    string version = 1;
    repeated TaxonomyNodeType node_types = 2;
    repeated TaxonomyRelationshipType relationship_types = 3;
    repeated TaxonomyTechnique techniques = 4;
    repeated TaxonomyTargetType target_types = 5;
    repeated TaxonomyTechniqueType technique_types = 6;
    repeated TaxonomyCapability capabilities = 7;
    HarnessError error = 8;
}

message TaxonomyNodeType {
    string id = 1;
    string name = 2;
    string type = 3;
    string category = 4;
    string description = 5;
    repeated string identifying_properties = 6;  // Properties used for deterministic ID generation
    repeated TaxonomyProperty properties = 7;
}

message TaxonomyRelationshipType {
    string id = 1;
    string name = 2;
    string type = 3;
    string category = 4;
    string description = 5;
    repeated string from_types = 6;
    repeated string to_types = 7;
    repeated TaxonomyProperty properties = 8;
    bool bidirectional = 9;
}

message TaxonomyTechnique {
    string technique_id = 1;
    string name = 2;
    string taxonomy = 3;  // mitre, arcanum, custom
    string category = 4;
    string description = 5;
    string tactic = 6;
    repeated string platforms = 7;
    repeated string mitre_mapping = 8;
}

message TaxonomyTargetType {
    string id = 1;
    string type = 2;
    string name = 3;
    string category = 4;
    string description = 5;
    repeated string required_fields = 6;
    repeated string optional_fields = 7;
}

message TaxonomyTechniqueType {
    string id = 1;
    string type = 2;
    string name = 3;
    string category = 4;
    string description = 5;
    repeated string mitre_ids = 6;
    string default_severity = 7;
}

message TaxonomyCapability {
    string id = 1;
    string name = 2;
    string description = 3;
    repeated string technique_types = 4;
}

message TaxonomyProperty {
    string name = 1;
    string type = 2;  // string, int, float64, bool, []string, map[string]any
    bool required = 3;
    string description = 4;
    repeated string enum_values = 5;
    string default_value = 6;  // JSON-encoded
}

message GenerateNodeIDRequest {
    ContextInfo context = 1;
    string node_type = 2;
    string properties_json = 3;  // JSON-encoded map[string]any
}

message GenerateNodeIDResponse {
    string node_id = 1;
    HarnessError error = 2;
}

message ValidateFindingRequest {
    ContextInfo context = 1;
    string finding_json = 2;  // JSON-encoded finding.Finding
}

message ValidateGraphNodeRequest {
    ContextInfo context = 1;
    string node_type = 2;
    string properties_json = 3;  // JSON-encoded map[string]any
}

message ValidateRelationshipRequest {
    ContextInfo context = 1;
    string relationship_type = 2;
    string from_node_type = 3;
    string to_node_type = 4;
    string properties_json = 5;  // JSON-encoded map[string]any
}

message ValidationResponse {
    bool valid = 1;
    repeated ValidationError errors = 2;
    repeated string warnings = 3;
    HarnessError error = 4;
}

message ValidationError {
    string field = 1;
    string message = 2;
    string code = 3;  // e.g., "MISSING_REQUIRED", "INVALID_ENUM", "UNKNOWN_TYPE"
}
