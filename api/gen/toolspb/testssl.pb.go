// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v4.25.1
// source: tools/testssl.proto

package toolspb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TestsslRequest represents input for the testssl.sh tool
type TestsslRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Targets is the list of hosts or URLs to test (required)
	Targets []string `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets,omitempty"`
	// Port is the target port (default: 443)
	Port int32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// Protocols tests SSL/TLS protocols
	Protocols bool `protobuf:"varint,3,opt,name=protocols,proto3" json:"protocols,omitempty"`
	// Ciphers tests cipher suites
	Ciphers bool `protobuf:"varint,4,opt,name=ciphers,proto3" json:"ciphers,omitempty"`
	// ServerDefaults tests server defaults
	ServerDefaults bool `protobuf:"varint,5,opt,name=server_defaults,json=serverDefaults,proto3" json:"server_defaults,omitempty"`
	// ServerPreference tests server cipher preference
	ServerPreference bool `protobuf:"varint,6,opt,name=server_preference,json=serverPreference,proto3" json:"server_preference,omitempty"`
	// Headers tests security headers
	Headers bool `protobuf:"varint,7,opt,name=headers,proto3" json:"headers,omitempty"`
	// Vulnerabilities tests known vulnerabilities
	Vulnerabilities bool `protobuf:"varint,8,opt,name=vulnerabilities,proto3" json:"vulnerabilities,omitempty"`
	// HeartbleedTest tests for Heartbleed vulnerability
	HeartbleedTest bool `protobuf:"varint,9,opt,name=heartbleed_test,json=heartbleedTest,proto3" json:"heartbleed_test,omitempty"`
	// CCSInjection tests for CCS injection vulnerability
	CcsInjection bool `protobuf:"varint,10,opt,name=ccs_injection,json=ccsInjection,proto3" json:"ccs_injection,omitempty"`
	// Ticketbleed tests for Ticketbleed vulnerability
	Ticketbleed bool `protobuf:"varint,11,opt,name=ticketbleed,proto3" json:"ticketbleed,omitempty"`
	// Robot tests for ROBOT attack vulnerability
	Robot bool `protobuf:"varint,12,opt,name=robot,proto3" json:"robot,omitempty"`
	// SecureRenegotiation tests for secure renegotiation
	SecureRenegotiation bool `protobuf:"varint,13,opt,name=secure_renegotiation,json=secureRenegotiation,proto3" json:"secure_renegotiation,omitempty"`
	// SecureClientRenegotiation tests for secure client-initiated renegotiation
	SecureClientRenegotiation bool `protobuf:"varint,14,opt,name=secure_client_renegotiation,json=secureClientRenegotiation,proto3" json:"secure_client_renegotiation,omitempty"`
	// Crime tests for CRIME vulnerability
	Crime bool `protobuf:"varint,15,opt,name=crime,proto3" json:"crime,omitempty"`
	// Breach tests for BREACH vulnerability
	Breach bool `protobuf:"varint,16,opt,name=breach,proto3" json:"breach,omitempty"`
	// Poodle tests for POODLE vulnerability
	Poodle bool `protobuf:"varint,17,opt,name=poodle,proto3" json:"poodle,omitempty"`
	// TLS_FALLBACK_SCSV tests for TLS_FALLBACK_SCSV support
	TlsFallbackScsv bool `protobuf:"varint,18,opt,name=tls_fallback_scsv,json=tlsFallbackScsv,proto3" json:"tls_fallback_scsv,omitempty"`
	// Sweet32 tests for SWEET32 vulnerability
	Sweet32 bool `protobuf:"varint,19,opt,name=sweet32,proto3" json:"sweet32,omitempty"`
	// Freak tests for FREAK vulnerability
	Freak bool `protobuf:"varint,20,opt,name=freak,proto3" json:"freak,omitempty"`
	// Drown tests for DROWN vulnerability
	Drown bool `protobuf:"varint,21,opt,name=drown,proto3" json:"drown,omitempty"`
	// Logjam tests for Logjam vulnerability
	Logjam bool `protobuf:"varint,22,opt,name=logjam,proto3" json:"logjam,omitempty"`
	// Beast tests for BEAST vulnerability
	Beast bool `protobuf:"varint,23,opt,name=beast,proto3" json:"beast,omitempty"`
	// Lucky13 tests for Lucky13 vulnerability
	Lucky13 bool `protobuf:"varint,24,opt,name=lucky13,proto3" json:"lucky13,omitempty"`
	// RC4 tests for RC4 cipher vulnerabilities
	Rc4 bool `protobuf:"varint,25,opt,name=rc4,proto3" json:"rc4,omitempty"`
	// PFS tests for Perfect Forward Secrecy
	Pfs bool `protobuf:"varint,26,opt,name=pfs,proto3" json:"pfs,omitempty"`
	// ServerName specifies SNI hostname
	ServerName string `protobuf:"bytes,27,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Timeout is the timeout in seconds for each test
	Timeout int32 `protobuf:"varint,28,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Quiet suppresses informational output
	Quiet         bool `protobuf:"varint,29,opt,name=quiet,proto3" json:"quiet,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TestsslRequest) Reset() {
	*x = TestsslRequest{}
	mi := &file_tools_testssl_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TestsslRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestsslRequest) ProtoMessage() {}

func (x *TestsslRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TestsslRequest.ProtoReflect.Descriptor instead.
func (*TestsslRequest) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{0}
}

func (x *TestsslRequest) GetTargets() []string {
	if x != nil {
		return x.Targets
	}
	return nil
}

func (x *TestsslRequest) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *TestsslRequest) GetProtocols() bool {
	if x != nil {
		return x.Protocols
	}
	return false
}

func (x *TestsslRequest) GetCiphers() bool {
	if x != nil {
		return x.Ciphers
	}
	return false
}

func (x *TestsslRequest) GetServerDefaults() bool {
	if x != nil {
		return x.ServerDefaults
	}
	return false
}

func (x *TestsslRequest) GetServerPreference() bool {
	if x != nil {
		return x.ServerPreference
	}
	return false
}

func (x *TestsslRequest) GetHeaders() bool {
	if x != nil {
		return x.Headers
	}
	return false
}

func (x *TestsslRequest) GetVulnerabilities() bool {
	if x != nil {
		return x.Vulnerabilities
	}
	return false
}

func (x *TestsslRequest) GetHeartbleedTest() bool {
	if x != nil {
		return x.HeartbleedTest
	}
	return false
}

func (x *TestsslRequest) GetCcsInjection() bool {
	if x != nil {
		return x.CcsInjection
	}
	return false
}

func (x *TestsslRequest) GetTicketbleed() bool {
	if x != nil {
		return x.Ticketbleed
	}
	return false
}

func (x *TestsslRequest) GetRobot() bool {
	if x != nil {
		return x.Robot
	}
	return false
}

func (x *TestsslRequest) GetSecureRenegotiation() bool {
	if x != nil {
		return x.SecureRenegotiation
	}
	return false
}

func (x *TestsslRequest) GetSecureClientRenegotiation() bool {
	if x != nil {
		return x.SecureClientRenegotiation
	}
	return false
}

func (x *TestsslRequest) GetCrime() bool {
	if x != nil {
		return x.Crime
	}
	return false
}

func (x *TestsslRequest) GetBreach() bool {
	if x != nil {
		return x.Breach
	}
	return false
}

func (x *TestsslRequest) GetPoodle() bool {
	if x != nil {
		return x.Poodle
	}
	return false
}

func (x *TestsslRequest) GetTlsFallbackScsv() bool {
	if x != nil {
		return x.TlsFallbackScsv
	}
	return false
}

func (x *TestsslRequest) GetSweet32() bool {
	if x != nil {
		return x.Sweet32
	}
	return false
}

func (x *TestsslRequest) GetFreak() bool {
	if x != nil {
		return x.Freak
	}
	return false
}

func (x *TestsslRequest) GetDrown() bool {
	if x != nil {
		return x.Drown
	}
	return false
}

func (x *TestsslRequest) GetLogjam() bool {
	if x != nil {
		return x.Logjam
	}
	return false
}

func (x *TestsslRequest) GetBeast() bool {
	if x != nil {
		return x.Beast
	}
	return false
}

func (x *TestsslRequest) GetLucky13() bool {
	if x != nil {
		return x.Lucky13
	}
	return false
}

func (x *TestsslRequest) GetRc4() bool {
	if x != nil {
		return x.Rc4
	}
	return false
}

func (x *TestsslRequest) GetPfs() bool {
	if x != nil {
		return x.Pfs
	}
	return false
}

func (x *TestsslRequest) GetServerName() string {
	if x != nil {
		return x.ServerName
	}
	return ""
}

func (x *TestsslRequest) GetTimeout() int32 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *TestsslRequest) GetQuiet() bool {
	if x != nil {
		return x.Quiet
	}
	return false
}

// TestsslResponse represents output from the testssl.sh tool
type TestsslResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Results contains the test results
	Results []*TestsslResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	// TotalTargets is the total number of targets tested
	TotalTargets int32 `protobuf:"varint,2,opt,name=total_targets,json=totalTargets,proto3" json:"total_targets,omitempty"`
	// Duration is the test duration in seconds
	Duration      float64 `protobuf:"fixed64,3,opt,name=duration,proto3" json:"duration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TestsslResponse) Reset() {
	*x = TestsslResponse{}
	mi := &file_tools_testssl_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TestsslResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestsslResponse) ProtoMessage() {}

func (x *TestsslResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TestsslResponse.ProtoReflect.Descriptor instead.
func (*TestsslResponse) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{1}
}

func (x *TestsslResponse) GetResults() []*TestsslResult {
	if x != nil {
		return x.Results
	}
	return nil
}

func (x *TestsslResponse) GetTotalTargets() int32 {
	if x != nil {
		return x.TotalTargets
	}
	return 0
}

func (x *TestsslResponse) GetDuration() float64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

// TestsslResult represents a single testssl.sh test result
type TestsslResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target is the tested target
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// IP is the target IP address
	Ip string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	// Port is the target port
	Port int32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// SSLInfo contains SSL/TLS information
	SslInfo *SSLInfo `protobuf:"bytes,4,opt,name=ssl_info,json=sslInfo,proto3" json:"ssl_info,omitempty"`
	// Protocols contains protocol test results
	Protocols []*ProtocolResult `protobuf:"bytes,5,rep,name=protocols,proto3" json:"protocols,omitempty"`
	// Ciphers contains cipher suite test results
	Ciphers []*CipherResult `protobuf:"bytes,6,rep,name=ciphers,proto3" json:"ciphers,omitempty"`
	// Vulnerabilities contains vulnerability test results
	Vulnerabilities []*VulnerabilityResult `protobuf:"bytes,7,rep,name=vulnerabilities,proto3" json:"vulnerabilities,omitempty"`
	// Headers contains security header results
	Headers map[string]string `protobuf:"bytes,8,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Certificate contains certificate information
	Certificate *CertificateInfo `protobuf:"bytes,9,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Error contains the error message if test failed
	Error         string `protobuf:"bytes,10,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TestsslResult) Reset() {
	*x = TestsslResult{}
	mi := &file_tools_testssl_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TestsslResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestsslResult) ProtoMessage() {}

func (x *TestsslResult) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TestsslResult.ProtoReflect.Descriptor instead.
func (*TestsslResult) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{2}
}

func (x *TestsslResult) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *TestsslResult) GetIp() string {
	if x != nil {
		return x.Ip
	}
	return ""
}

func (x *TestsslResult) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *TestsslResult) GetSslInfo() *SSLInfo {
	if x != nil {
		return x.SslInfo
	}
	return nil
}

func (x *TestsslResult) GetProtocols() []*ProtocolResult {
	if x != nil {
		return x.Protocols
	}
	return nil
}

func (x *TestsslResult) GetCiphers() []*CipherResult {
	if x != nil {
		return x.Ciphers
	}
	return nil
}

func (x *TestsslResult) GetVulnerabilities() []*VulnerabilityResult {
	if x != nil {
		return x.Vulnerabilities
	}
	return nil
}

func (x *TestsslResult) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *TestsslResult) GetCertificate() *CertificateInfo {
	if x != nil {
		return x.Certificate
	}
	return nil
}

func (x *TestsslResult) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// SSLInfo contains SSL/TLS information
type SSLInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ServerCipherOrder indicates if server determines cipher order
	ServerCipherOrder string `protobuf:"bytes,1,opt,name=server_cipher_order,json=serverCipherOrder,proto3" json:"server_cipher_order,omitempty"`
	// TLSExtensions contains supported TLS extensions
	TlsExtensions []string `protobuf:"bytes,2,rep,name=tls_extensions,json=tlsExtensions,proto3" json:"tls_extensions,omitempty"`
	// SessionResumption indicates session resumption support
	SessionResumption string `protobuf:"bytes,3,opt,name=session_resumption,json=sessionResumption,proto3" json:"session_resumption,omitempty"`
	// TLSTickets indicates TLS tickets support
	TlsTickets string `protobuf:"bytes,4,opt,name=tls_tickets,json=tlsTickets,proto3" json:"tls_tickets,omitempty"`
	// OCSP indicates OCSP stapling support
	Ocsp string `protobuf:"bytes,5,opt,name=ocsp,proto3" json:"ocsp,omitempty"`
	// HSTS indicates HTTP Strict Transport Security
	Hsts string `protobuf:"bytes,6,opt,name=hsts,proto3" json:"hsts,omitempty"`
	// HPKP indicates HTTP Public Key Pinning
	Hpkp          string `protobuf:"bytes,7,opt,name=hpkp,proto3" json:"hpkp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSLInfo) Reset() {
	*x = SSLInfo{}
	mi := &file_tools_testssl_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSLInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSLInfo) ProtoMessage() {}

func (x *SSLInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSLInfo.ProtoReflect.Descriptor instead.
func (*SSLInfo) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{3}
}

func (x *SSLInfo) GetServerCipherOrder() string {
	if x != nil {
		return x.ServerCipherOrder
	}
	return ""
}

func (x *SSLInfo) GetTlsExtensions() []string {
	if x != nil {
		return x.TlsExtensions
	}
	return nil
}

func (x *SSLInfo) GetSessionResumption() string {
	if x != nil {
		return x.SessionResumption
	}
	return ""
}

func (x *SSLInfo) GetTlsTickets() string {
	if x != nil {
		return x.TlsTickets
	}
	return ""
}

func (x *SSLInfo) GetOcsp() string {
	if x != nil {
		return x.Ocsp
	}
	return ""
}

func (x *SSLInfo) GetHsts() string {
	if x != nil {
		return x.Hsts
	}
	return ""
}

func (x *SSLInfo) GetHpkp() string {
	if x != nil {
		return x.Hpkp
	}
	return ""
}

// ProtocolResult contains protocol test result
type ProtocolResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Protocol is the protocol name (SSLv2, SSLv3, TLS1.0, TLS1.1, TLS1.2, TLS1.3)
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Supported indicates if the protocol is supported
	Supported bool `protobuf:"varint,2,opt,name=supported,proto3" json:"supported,omitempty"`
	// Severity indicates the severity level if protocol has issues
	Severity string `protobuf:"bytes,3,opt,name=severity,proto3" json:"severity,omitempty"`
	// Finding contains the finding description
	Finding       string `protobuf:"bytes,4,opt,name=finding,proto3" json:"finding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProtocolResult) Reset() {
	*x = ProtocolResult{}
	mi := &file_tools_testssl_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtocolResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtocolResult) ProtoMessage() {}

func (x *ProtocolResult) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtocolResult.ProtoReflect.Descriptor instead.
func (*ProtocolResult) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{4}
}

func (x *ProtocolResult) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *ProtocolResult) GetSupported() bool {
	if x != nil {
		return x.Supported
	}
	return false
}

func (x *ProtocolResult) GetSeverity() string {
	if x != nil {
		return x.Severity
	}
	return ""
}

func (x *ProtocolResult) GetFinding() string {
	if x != nil {
		return x.Finding
	}
	return ""
}

// CipherResult contains cipher suite test result
type CipherResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Cipher is the cipher suite name
	Cipher string `protobuf:"bytes,1,opt,name=cipher,proto3" json:"cipher,omitempty"`
	// Protocol is the protocol version
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// KeyExchange is the key exchange algorithm
	KeyExchange string `protobuf:"bytes,3,opt,name=key_exchange,json=keyExchange,proto3" json:"key_exchange,omitempty"`
	// Encryption is the encryption algorithm
	Encryption string `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// Bits is the cipher strength in bits
	Bits int32 `protobuf:"varint,5,opt,name=bits,proto3" json:"bits,omitempty"`
	// Severity indicates the severity level
	Severity      string `protobuf:"bytes,6,opt,name=severity,proto3" json:"severity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CipherResult) Reset() {
	*x = CipherResult{}
	mi := &file_tools_testssl_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CipherResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CipherResult) ProtoMessage() {}

func (x *CipherResult) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CipherResult.ProtoReflect.Descriptor instead.
func (*CipherResult) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{5}
}

func (x *CipherResult) GetCipher() string {
	if x != nil {
		return x.Cipher
	}
	return ""
}

func (x *CipherResult) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *CipherResult) GetKeyExchange() string {
	if x != nil {
		return x.KeyExchange
	}
	return ""
}

func (x *CipherResult) GetEncryption() string {
	if x != nil {
		return x.Encryption
	}
	return ""
}

func (x *CipherResult) GetBits() int32 {
	if x != nil {
		return x.Bits
	}
	return 0
}

func (x *CipherResult) GetSeverity() string {
	if x != nil {
		return x.Severity
	}
	return ""
}

// VulnerabilityResult contains vulnerability test result
type VulnerabilityResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID is the vulnerability identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name is the vulnerability name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Vulnerable indicates if target is vulnerable
	Vulnerable bool `protobuf:"varint,3,opt,name=vulnerable,proto3" json:"vulnerable,omitempty"`
	// Severity is the severity level (OK, LOW, MEDIUM, HIGH, CRITICAL)
	Severity string `protobuf:"bytes,4,opt,name=severity,proto3" json:"severity,omitempty"`
	// Finding contains the finding description
	Finding string `protobuf:"bytes,5,opt,name=finding,proto3" json:"finding,omitempty"`
	// CVE contains related CVE identifiers
	Cve           []string `protobuf:"bytes,6,rep,name=cve,proto3" json:"cve,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VulnerabilityResult) Reset() {
	*x = VulnerabilityResult{}
	mi := &file_tools_testssl_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VulnerabilityResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VulnerabilityResult) ProtoMessage() {}

func (x *VulnerabilityResult) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VulnerabilityResult.ProtoReflect.Descriptor instead.
func (*VulnerabilityResult) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{6}
}

func (x *VulnerabilityResult) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *VulnerabilityResult) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VulnerabilityResult) GetVulnerable() bool {
	if x != nil {
		return x.Vulnerable
	}
	return false
}

func (x *VulnerabilityResult) GetSeverity() string {
	if x != nil {
		return x.Severity
	}
	return ""
}

func (x *VulnerabilityResult) GetFinding() string {
	if x != nil {
		return x.Finding
	}
	return ""
}

func (x *VulnerabilityResult) GetCve() []string {
	if x != nil {
		return x.Cve
	}
	return nil
}

// CertificateInfo contains certificate information
type CertificateInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SubjectDN is the certificate subject
	SubjectDn string `protobuf:"bytes,1,opt,name=subject_dn,json=subjectDn,proto3" json:"subject_dn,omitempty"`
	// IssuerDN is the certificate issuer
	IssuerDn string `protobuf:"bytes,2,opt,name=issuer_dn,json=issuerDn,proto3" json:"issuer_dn,omitempty"`
	// NotBefore is the validity start date
	NotBefore string `protobuf:"bytes,3,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// NotAfter is the validity end date
	NotAfter string `protobuf:"bytes,4,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	// SANs contains Subject Alternative Names
	Sans []string `protobuf:"bytes,5,rep,name=sans,proto3" json:"sans,omitempty"`
	// SerialNumber is the certificate serial number
	SerialNumber string `protobuf:"bytes,6,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	// SignatureAlgorithm is the signature algorithm
	SignatureAlgorithm string `protobuf:"bytes,7,opt,name=signature_algorithm,json=signatureAlgorithm,proto3" json:"signature_algorithm,omitempty"`
	// PublicKeyAlgorithm is the public key algorithm
	PublicKeyAlgorithm string `protobuf:"bytes,8,opt,name=public_key_algorithm,json=publicKeyAlgorithm,proto3" json:"public_key_algorithm,omitempty"`
	// PublicKeySize is the public key size in bits
	PublicKeySize int32 `protobuf:"varint,9,opt,name=public_key_size,json=publicKeySize,proto3" json:"public_key_size,omitempty"`
	// FingerprintSHA1 is the SHA1 fingerprint
	FingerprintSha1 string `protobuf:"bytes,10,opt,name=fingerprint_sha1,json=fingerprintSha1,proto3" json:"fingerprint_sha1,omitempty"`
	// FingerprintSHA256 is the SHA256 fingerprint
	FingerprintSha256 string `protobuf:"bytes,11,opt,name=fingerprint_sha256,json=fingerprintSha256,proto3" json:"fingerprint_sha256,omitempty"`
	// Expired indicates if certificate is expired
	Expired bool `protobuf:"varint,12,opt,name=expired,proto3" json:"expired,omitempty"`
	// SelfSigned indicates if certificate is self-signed
	SelfSigned bool `protobuf:"varint,13,opt,name=self_signed,json=selfSigned,proto3" json:"self_signed,omitempty"`
	// TrustChain contains the certificate trust chain
	TrustChain    []string `protobuf:"bytes,14,rep,name=trust_chain,json=trustChain,proto3" json:"trust_chain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CertificateInfo) Reset() {
	*x = CertificateInfo{}
	mi := &file_tools_testssl_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CertificateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CertificateInfo) ProtoMessage() {}

func (x *CertificateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tools_testssl_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CertificateInfo.ProtoReflect.Descriptor instead.
func (*CertificateInfo) Descriptor() ([]byte, []int) {
	return file_tools_testssl_proto_rawDescGZIP(), []int{7}
}

func (x *CertificateInfo) GetSubjectDn() string {
	if x != nil {
		return x.SubjectDn
	}
	return ""
}

func (x *CertificateInfo) GetIssuerDn() string {
	if x != nil {
		return x.IssuerDn
	}
	return ""
}

func (x *CertificateInfo) GetNotBefore() string {
	if x != nil {
		return x.NotBefore
	}
	return ""
}

func (x *CertificateInfo) GetNotAfter() string {
	if x != nil {
		return x.NotAfter
	}
	return ""
}

func (x *CertificateInfo) GetSans() []string {
	if x != nil {
		return x.Sans
	}
	return nil
}

func (x *CertificateInfo) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *CertificateInfo) GetSignatureAlgorithm() string {
	if x != nil {
		return x.SignatureAlgorithm
	}
	return ""
}

func (x *CertificateInfo) GetPublicKeyAlgorithm() string {
	if x != nil {
		return x.PublicKeyAlgorithm
	}
	return ""
}

func (x *CertificateInfo) GetPublicKeySize() int32 {
	if x != nil {
		return x.PublicKeySize
	}
	return 0
}

func (x *CertificateInfo) GetFingerprintSha1() string {
	if x != nil {
		return x.FingerprintSha1
	}
	return ""
}

func (x *CertificateInfo) GetFingerprintSha256() string {
	if x != nil {
		return x.FingerprintSha256
	}
	return ""
}

func (x *CertificateInfo) GetExpired() bool {
	if x != nil {
		return x.Expired
	}
	return false
}

func (x *CertificateInfo) GetSelfSigned() bool {
	if x != nil {
		return x.SelfSigned
	}
	return false
}

func (x *CertificateInfo) GetTrustChain() []string {
	if x != nil {
		return x.TrustChain
	}
	return nil
}

var File_tools_testssl_proto protoreflect.FileDescriptor

const file_tools_testssl_proto_rawDesc = "" +
	"\n" +
	"\x13tools/testssl.proto\x12\fgibson.tools\"\xfe\x06\n" +
	"\x0eTestsslRequest\x12\x18\n" +
	"\atargets\x18\x01 \x03(\tR\atargets\x12\x12\n" +
	"\x04port\x18\x02 \x01(\x05R\x04port\x12\x1c\n" +
	"\tprotocols\x18\x03 \x01(\bR\tprotocols\x12\x18\n" +
	"\aciphers\x18\x04 \x01(\bR\aciphers\x12'\n" +
	"\x0fserver_defaults\x18\x05 \x01(\bR\x0eserverDefaults\x12+\n" +
	"\x11server_preference\x18\x06 \x01(\bR\x10serverPreference\x12\x18\n" +
	"\aheaders\x18\a \x01(\bR\aheaders\x12(\n" +
	"\x0fvulnerabilities\x18\b \x01(\bR\x0fvulnerabilities\x12'\n" +
	"\x0fheartbleed_test\x18\t \x01(\bR\x0eheartbleedTest\x12#\n" +
	"\rccs_injection\x18\n" +
	" \x01(\bR\fccsInjection\x12 \n" +
	"\vticketbleed\x18\v \x01(\bR\vticketbleed\x12\x14\n" +
	"\x05robot\x18\f \x01(\bR\x05robot\x121\n" +
	"\x14secure_renegotiation\x18\r \x01(\bR\x13secureRenegotiation\x12>\n" +
	"\x1bsecure_client_renegotiation\x18\x0e \x01(\bR\x19secureClientRenegotiation\x12\x14\n" +
	"\x05crime\x18\x0f \x01(\bR\x05crime\x12\x16\n" +
	"\x06breach\x18\x10 \x01(\bR\x06breach\x12\x16\n" +
	"\x06poodle\x18\x11 \x01(\bR\x06poodle\x12*\n" +
	"\x11tls_fallback_scsv\x18\x12 \x01(\bR\x0ftlsFallbackScsv\x12\x18\n" +
	"\asweet32\x18\x13 \x01(\bR\asweet32\x12\x14\n" +
	"\x05freak\x18\x14 \x01(\bR\x05freak\x12\x14\n" +
	"\x05drown\x18\x15 \x01(\bR\x05drown\x12\x16\n" +
	"\x06logjam\x18\x16 \x01(\bR\x06logjam\x12\x14\n" +
	"\x05beast\x18\x17 \x01(\bR\x05beast\x12\x18\n" +
	"\alucky13\x18\x18 \x01(\bR\alucky13\x12\x10\n" +
	"\x03rc4\x18\x19 \x01(\bR\x03rc4\x12\x10\n" +
	"\x03pfs\x18\x1a \x01(\bR\x03pfs\x12\x1f\n" +
	"\vserver_name\x18\x1b \x01(\tR\n" +
	"serverName\x12\x18\n" +
	"\atimeout\x18\x1c \x01(\x05R\atimeout\x12\x14\n" +
	"\x05quiet\x18\x1d \x01(\bR\x05quiet\"\x89\x01\n" +
	"\x0fTestsslResponse\x125\n" +
	"\aresults\x18\x01 \x03(\v2\x1b.gibson.tools.TestsslResultR\aresults\x12#\n" +
	"\rtotal_targets\x18\x02 \x01(\x05R\ftotalTargets\x12\x1a\n" +
	"\bduration\x18\x03 \x01(\x01R\bduration\"\x93\x04\n" +
	"\rTestsslResult\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target\x12\x0e\n" +
	"\x02ip\x18\x02 \x01(\tR\x02ip\x12\x12\n" +
	"\x04port\x18\x03 \x01(\x05R\x04port\x120\n" +
	"\bssl_info\x18\x04 \x01(\v2\x15.gibson.tools.SSLInfoR\asslInfo\x12:\n" +
	"\tprotocols\x18\x05 \x03(\v2\x1c.gibson.tools.ProtocolResultR\tprotocols\x124\n" +
	"\aciphers\x18\x06 \x03(\v2\x1a.gibson.tools.CipherResultR\aciphers\x12K\n" +
	"\x0fvulnerabilities\x18\a \x03(\v2!.gibson.tools.VulnerabilityResultR\x0fvulnerabilities\x12B\n" +
	"\aheaders\x18\b \x03(\v2(.gibson.tools.TestsslResult.HeadersEntryR\aheaders\x12?\n" +
	"\vcertificate\x18\t \x01(\v2\x1d.gibson.tools.CertificateInfoR\vcertificate\x12\x14\n" +
	"\x05error\x18\n" +
	" \x01(\tR\x05error\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xec\x01\n" +
	"\aSSLInfo\x12.\n" +
	"\x13server_cipher_order\x18\x01 \x01(\tR\x11serverCipherOrder\x12%\n" +
	"\x0etls_extensions\x18\x02 \x03(\tR\rtlsExtensions\x12-\n" +
	"\x12session_resumption\x18\x03 \x01(\tR\x11sessionResumption\x12\x1f\n" +
	"\vtls_tickets\x18\x04 \x01(\tR\n" +
	"tlsTickets\x12\x12\n" +
	"\x04ocsp\x18\x05 \x01(\tR\x04ocsp\x12\x12\n" +
	"\x04hsts\x18\x06 \x01(\tR\x04hsts\x12\x12\n" +
	"\x04hpkp\x18\a \x01(\tR\x04hpkp\"\x80\x01\n" +
	"\x0eProtocolResult\x12\x1a\n" +
	"\bprotocol\x18\x01 \x01(\tR\bprotocol\x12\x1c\n" +
	"\tsupported\x18\x02 \x01(\bR\tsupported\x12\x1a\n" +
	"\bseverity\x18\x03 \x01(\tR\bseverity\x12\x18\n" +
	"\afinding\x18\x04 \x01(\tR\afinding\"\xb5\x01\n" +
	"\fCipherResult\x12\x16\n" +
	"\x06cipher\x18\x01 \x01(\tR\x06cipher\x12\x1a\n" +
	"\bprotocol\x18\x02 \x01(\tR\bprotocol\x12!\n" +
	"\fkey_exchange\x18\x03 \x01(\tR\vkeyExchange\x12\x1e\n" +
	"\n" +
	"encryption\x18\x04 \x01(\tR\n" +
	"encryption\x12\x12\n" +
	"\x04bits\x18\x05 \x01(\x05R\x04bits\x12\x1a\n" +
	"\bseverity\x18\x06 \x01(\tR\bseverity\"\xa1\x01\n" +
	"\x13VulnerabilityResult\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1e\n" +
	"\n" +
	"vulnerable\x18\x03 \x01(\bR\n" +
	"vulnerable\x12\x1a\n" +
	"\bseverity\x18\x04 \x01(\tR\bseverity\x12\x18\n" +
	"\afinding\x18\x05 \x01(\tR\afinding\x12\x10\n" +
	"\x03cve\x18\x06 \x03(\tR\x03cve\"\x83\x04\n" +
	"\x0fCertificateInfo\x12\x1d\n" +
	"\n" +
	"subject_dn\x18\x01 \x01(\tR\tsubjectDn\x12\x1b\n" +
	"\tissuer_dn\x18\x02 \x01(\tR\bissuerDn\x12\x1d\n" +
	"\n" +
	"not_before\x18\x03 \x01(\tR\tnotBefore\x12\x1b\n" +
	"\tnot_after\x18\x04 \x01(\tR\bnotAfter\x12\x12\n" +
	"\x04sans\x18\x05 \x03(\tR\x04sans\x12#\n" +
	"\rserial_number\x18\x06 \x01(\tR\fserialNumber\x12/\n" +
	"\x13signature_algorithm\x18\a \x01(\tR\x12signatureAlgorithm\x120\n" +
	"\x14public_key_algorithm\x18\b \x01(\tR\x12publicKeyAlgorithm\x12&\n" +
	"\x0fpublic_key_size\x18\t \x01(\x05R\rpublicKeySize\x12)\n" +
	"\x10fingerprint_sha1\x18\n" +
	" \x01(\tR\x0ffingerprintSha1\x12-\n" +
	"\x12fingerprint_sha256\x18\v \x01(\tR\x11fingerprintSha256\x12\x18\n" +
	"\aexpired\x18\f \x01(\bR\aexpired\x12\x1f\n" +
	"\vself_signed\x18\r \x01(\bR\n" +
	"selfSigned\x12\x1f\n" +
	"\vtrust_chain\x18\x0e \x03(\tR\n" +
	"trustChainB,Z*github.com/zero-day-ai/sdk/api/gen/toolspbb\x06proto3"

var (
	file_tools_testssl_proto_rawDescOnce sync.Once
	file_tools_testssl_proto_rawDescData []byte
)

func file_tools_testssl_proto_rawDescGZIP() []byte {
	file_tools_testssl_proto_rawDescOnce.Do(func() {
		file_tools_testssl_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tools_testssl_proto_rawDesc), len(file_tools_testssl_proto_rawDesc)))
	})
	return file_tools_testssl_proto_rawDescData
}

var file_tools_testssl_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_tools_testssl_proto_goTypes = []any{
	(*TestsslRequest)(nil),      // 0: gibson.tools.TestsslRequest
	(*TestsslResponse)(nil),     // 1: gibson.tools.TestsslResponse
	(*TestsslResult)(nil),       // 2: gibson.tools.TestsslResult
	(*SSLInfo)(nil),             // 3: gibson.tools.SSLInfo
	(*ProtocolResult)(nil),      // 4: gibson.tools.ProtocolResult
	(*CipherResult)(nil),        // 5: gibson.tools.CipherResult
	(*VulnerabilityResult)(nil), // 6: gibson.tools.VulnerabilityResult
	(*CertificateInfo)(nil),     // 7: gibson.tools.CertificateInfo
	nil,                         // 8: gibson.tools.TestsslResult.HeadersEntry
}
var file_tools_testssl_proto_depIdxs = []int32{
	2, // 0: gibson.tools.TestsslResponse.results:type_name -> gibson.tools.TestsslResult
	3, // 1: gibson.tools.TestsslResult.ssl_info:type_name -> gibson.tools.SSLInfo
	4, // 2: gibson.tools.TestsslResult.protocols:type_name -> gibson.tools.ProtocolResult
	5, // 3: gibson.tools.TestsslResult.ciphers:type_name -> gibson.tools.CipherResult
	6, // 4: gibson.tools.TestsslResult.vulnerabilities:type_name -> gibson.tools.VulnerabilityResult
	8, // 5: gibson.tools.TestsslResult.headers:type_name -> gibson.tools.TestsslResult.HeadersEntry
	7, // 6: gibson.tools.TestsslResult.certificate:type_name -> gibson.tools.CertificateInfo
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_tools_testssl_proto_init() }
func file_tools_testssl_proto_init() {
	if File_tools_testssl_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tools_testssl_proto_rawDesc), len(file_tools_testssl_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tools_testssl_proto_goTypes,
		DependencyIndexes: file_tools_testssl_proto_depIdxs,
		MessageInfos:      file_tools_testssl_proto_msgTypes,
	}.Build()
	File_tools_testssl_proto = out.File
	file_tools_testssl_proto_goTypes = nil
	file_tools_testssl_proto_depIdxs = nil
}
