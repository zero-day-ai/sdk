// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v4.25.1
// source: workflow.proto

package workflowpb

import (
	proto "github.com/zero-day-ai/sdk/api/gen/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// NodeType defines the type of workflow node
type NodeType int32

const (
	// Sentinel value - must be first
	NodeType_NODE_TYPE_UNSPECIFIED NodeType = 0
	// Agent node executes an agent
	NodeType_NODE_TYPE_AGENT NodeType = 1
	// Tool node executes a tool
	NodeType_NODE_TYPE_TOOL NodeType = 2
	// Plugin node queries a plugin
	NodeType_NODE_TYPE_PLUGIN NodeType = 3
	// Condition node performs conditional branching
	NodeType_NODE_TYPE_CONDITION NodeType = 4
	// Parallel node executes sub-nodes in parallel
	NodeType_NODE_TYPE_PARALLEL NodeType = 5
	// Join node waits for multiple branches to complete
	NodeType_NODE_TYPE_JOIN NodeType = 6
)

// Enum value maps for NodeType.
var (
	NodeType_name = map[int32]string{
		0: "NODE_TYPE_UNSPECIFIED",
		1: "NODE_TYPE_AGENT",
		2: "NODE_TYPE_TOOL",
		3: "NODE_TYPE_PLUGIN",
		4: "NODE_TYPE_CONDITION",
		5: "NODE_TYPE_PARALLEL",
		6: "NODE_TYPE_JOIN",
	}
	NodeType_value = map[string]int32{
		"NODE_TYPE_UNSPECIFIED": 0,
		"NODE_TYPE_AGENT":       1,
		"NODE_TYPE_TOOL":        2,
		"NODE_TYPE_PLUGIN":      3,
		"NODE_TYPE_CONDITION":   4,
		"NODE_TYPE_PARALLEL":    5,
		"NODE_TYPE_JOIN":        6,
	}
)

func (x NodeType) Enum() *NodeType {
	p := new(NodeType)
	*p = x
	return p
}

func (x NodeType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeType) Descriptor() protoreflect.EnumDescriptor {
	return file_workflow_proto_enumTypes[0].Descriptor()
}

func (NodeType) Type() protoreflect.EnumType {
	return &file_workflow_proto_enumTypes[0]
}

func (x NodeType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeType.Descriptor instead.
func (NodeType) EnumDescriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{0}
}

// BackoffStrategy defines the strategy for calculating retry delays
type BackoffStrategy int32

const (
	// Sentinel value - must be first
	BackoffStrategy_BACKOFF_STRATEGY_UNSPECIFIED BackoffStrategy = 0
	// Constant returns a constant delay for all retry attempts
	BackoffStrategy_BACKOFF_STRATEGY_CONSTANT BackoffStrategy = 1
	// Linear increases the delay linearly with each retry attempt
	BackoffStrategy_BACKOFF_STRATEGY_LINEAR BackoffStrategy = 2
	// Exponential increases the delay exponentially with each retry attempt
	BackoffStrategy_BACKOFF_STRATEGY_EXPONENTIAL BackoffStrategy = 3
)

// Enum value maps for BackoffStrategy.
var (
	BackoffStrategy_name = map[int32]string{
		0: "BACKOFF_STRATEGY_UNSPECIFIED",
		1: "BACKOFF_STRATEGY_CONSTANT",
		2: "BACKOFF_STRATEGY_LINEAR",
		3: "BACKOFF_STRATEGY_EXPONENTIAL",
	}
	BackoffStrategy_value = map[string]int32{
		"BACKOFF_STRATEGY_UNSPECIFIED": 0,
		"BACKOFF_STRATEGY_CONSTANT":    1,
		"BACKOFF_STRATEGY_LINEAR":      2,
		"BACKOFF_STRATEGY_EXPONENTIAL": 3,
	}
)

func (x BackoffStrategy) Enum() *BackoffStrategy {
	p := new(BackoffStrategy)
	*p = x
	return p
}

func (x BackoffStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BackoffStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_workflow_proto_enumTypes[1].Descriptor()
}

func (BackoffStrategy) Type() protoreflect.EnumType {
	return &file_workflow_proto_enumTypes[1]
}

func (x BackoffStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BackoffStrategy.Descriptor instead.
func (BackoffStrategy) EnumDescriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{1}
}

// WorkflowDefinition represents a mission template/definition loaded from YAML.
// This is the installable, shareable mission specification that can be stored
// in git repositories and managed through the mission install/uninstall commands.
type WorkflowDefinition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID is the unique identifier for this workflow definition
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name is a human-readable name for the workflow
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description provides additional context about what this workflow does
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Version is the semantic version of the workflow definition
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// TargetRef is a reference to the target (name or ID) from the YAML
	// This needs to be resolved to a TargetID when creating a mission instance
	TargetRef string `protobuf:"bytes,5,opt,name=target_ref,json=targetRef,proto3" json:"target_ref,omitempty"`
	// Nodes contains all the nodes in the workflow, indexed by node ID
	Nodes map[string]*WorkflowNode `protobuf:"bytes,6,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Edges contains all the directed edges connecting nodes in the workflow
	Edges []*WorkflowEdge `protobuf:"bytes,7,rep,name=edges,proto3" json:"edges,omitempty"`
	// EntryPoints contains the IDs of nodes that can serve as entry points to the workflow
	// These are nodes with no incoming edges
	EntryPoints []string `protobuf:"bytes,8,rep,name=entry_points,json=entryPoints,proto3" json:"entry_points,omitempty"`
	// ExitPoints contains the IDs of nodes that can serve as exit points from the workflow
	// These are nodes with no outgoing edges
	ExitPoints []string `protobuf:"bytes,9,rep,name=exit_points,json=exitPoints,proto3" json:"exit_points,omitempty"`
	// Metadata contains additional custom metadata for the workflow
	Metadata map[string]string `protobuf:"bytes,10,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Dependencies specifies required agents and tools for this workflow
	Dependencies *WorkflowDependencies `protobuf:"bytes,11,opt,name=dependencies,proto3" json:"dependencies,omitempty"`
	// Source is the git URL this workflow was installed from (if applicable)
	Source string `protobuf:"bytes,12,opt,name=source,proto3" json:"source,omitempty"`
	// InstalledAt is the timestamp when this workflow was installed
	InstalledAt *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=installed_at,json=installedAt,proto3" json:"installed_at,omitempty"`
	// CreatedAt is the timestamp when the workflow definition was created
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowDefinition) Reset() {
	*x = WorkflowDefinition{}
	mi := &file_workflow_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowDefinition) ProtoMessage() {}

func (x *WorkflowDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowDefinition.ProtoReflect.Descriptor instead.
func (*WorkflowDefinition) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{0}
}

func (x *WorkflowDefinition) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *WorkflowDefinition) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *WorkflowDefinition) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *WorkflowDefinition) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *WorkflowDefinition) GetTargetRef() string {
	if x != nil {
		return x.TargetRef
	}
	return ""
}

func (x *WorkflowDefinition) GetNodes() map[string]*WorkflowNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *WorkflowDefinition) GetEdges() []*WorkflowEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

func (x *WorkflowDefinition) GetEntryPoints() []string {
	if x != nil {
		return x.EntryPoints
	}
	return nil
}

func (x *WorkflowDefinition) GetExitPoints() []string {
	if x != nil {
		return x.ExitPoints
	}
	return nil
}

func (x *WorkflowDefinition) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *WorkflowDefinition) GetDependencies() *WorkflowDependencies {
	if x != nil {
		return x.Dependencies
	}
	return nil
}

func (x *WorkflowDefinition) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *WorkflowDefinition) GetInstalledAt() *timestamppb.Timestamp {
	if x != nil {
		return x.InstalledAt
	}
	return nil
}

func (x *WorkflowDefinition) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

// WorkflowDependencies specifies required components for a workflow
type WorkflowDependencies struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Agents lists required agent components by name or URL
	Agents []string `protobuf:"bytes,1,rep,name=agents,proto3" json:"agents,omitempty"`
	// Tools lists required tool components by name or URL
	Tools []string `protobuf:"bytes,2,rep,name=tools,proto3" json:"tools,omitempty"`
	// Plugins lists required plugin components by name or URL
	Plugins       []string `protobuf:"bytes,3,rep,name=plugins,proto3" json:"plugins,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowDependencies) Reset() {
	*x = WorkflowDependencies{}
	mi := &file_workflow_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowDependencies) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowDependencies) ProtoMessage() {}

func (x *WorkflowDependencies) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowDependencies.ProtoReflect.Descriptor instead.
func (*WorkflowDependencies) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{1}
}

func (x *WorkflowDependencies) GetAgents() []string {
	if x != nil {
		return x.Agents
	}
	return nil
}

func (x *WorkflowDependencies) GetTools() []string {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *WorkflowDependencies) GetPlugins() []string {
	if x != nil {
		return x.Plugins
	}
	return nil
}

// WorkflowNode represents a single node in a workflow DAG
type WorkflowNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID is the unique identifier for this node within the workflow
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Type is the node type
	Type NodeType `protobuf:"varint,2,opt,name=type,proto3,enum=gibson.workflow.NodeType" json:"type,omitempty"`
	// Name is a human-readable name for the node
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description provides additional context about this node
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Config contains the type-specific configuration (oneof)
	//
	// Types that are valid to be assigned to Config:
	//
	//	*WorkflowNode_AgentConfig
	//	*WorkflowNode_ToolConfig
	//	*WorkflowNode_PluginConfig
	//	*WorkflowNode_ConditionConfig
	//	*WorkflowNode_ParallelConfig
	Config isWorkflowNode_Config `protobuf_oneof:"config"`
	// Dependencies lists node IDs that must complete before this node executes
	Dependencies []string `protobuf:"bytes,10,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
	// Timeout is the maximum execution time for this node
	Timeout *durationpb.Duration `protobuf:"bytes,11,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// RetryPolicy defines retry behavior for this node
	RetryPolicy *RetryPolicy `protobuf:"bytes,12,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// DataPolicy defines data handling policy for this node
	DataPolicy *DataPolicy `protobuf:"bytes,13,opt,name=data_policy,json=dataPolicy,proto3" json:"data_policy,omitempty"`
	// Metadata contains additional custom metadata for this node
	Metadata      map[string]string `protobuf:"bytes,14,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowNode) Reset() {
	*x = WorkflowNode{}
	mi := &file_workflow_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowNode) ProtoMessage() {}

func (x *WorkflowNode) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowNode.ProtoReflect.Descriptor instead.
func (*WorkflowNode) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{2}
}

func (x *WorkflowNode) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *WorkflowNode) GetType() NodeType {
	if x != nil {
		return x.Type
	}
	return NodeType_NODE_TYPE_UNSPECIFIED
}

func (x *WorkflowNode) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *WorkflowNode) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *WorkflowNode) GetConfig() isWorkflowNode_Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *WorkflowNode) GetAgentConfig() *AgentNodeConfig {
	if x != nil {
		if x, ok := x.Config.(*WorkflowNode_AgentConfig); ok {
			return x.AgentConfig
		}
	}
	return nil
}

func (x *WorkflowNode) GetToolConfig() *ToolNodeConfig {
	if x != nil {
		if x, ok := x.Config.(*WorkflowNode_ToolConfig); ok {
			return x.ToolConfig
		}
	}
	return nil
}

func (x *WorkflowNode) GetPluginConfig() *PluginNodeConfig {
	if x != nil {
		if x, ok := x.Config.(*WorkflowNode_PluginConfig); ok {
			return x.PluginConfig
		}
	}
	return nil
}

func (x *WorkflowNode) GetConditionConfig() *ConditionNodeConfig {
	if x != nil {
		if x, ok := x.Config.(*WorkflowNode_ConditionConfig); ok {
			return x.ConditionConfig
		}
	}
	return nil
}

func (x *WorkflowNode) GetParallelConfig() *ParallelNodeConfig {
	if x != nil {
		if x, ok := x.Config.(*WorkflowNode_ParallelConfig); ok {
			return x.ParallelConfig
		}
	}
	return nil
}

func (x *WorkflowNode) GetDependencies() []string {
	if x != nil {
		return x.Dependencies
	}
	return nil
}

func (x *WorkflowNode) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *WorkflowNode) GetRetryPolicy() *RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

func (x *WorkflowNode) GetDataPolicy() *DataPolicy {
	if x != nil {
		return x.DataPolicy
	}
	return nil
}

func (x *WorkflowNode) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type isWorkflowNode_Config interface {
	isWorkflowNode_Config()
}

type WorkflowNode_AgentConfig struct {
	// AgentConfig for agent nodes
	AgentConfig *AgentNodeConfig `protobuf:"bytes,5,opt,name=agent_config,json=agentConfig,proto3,oneof"`
}

type WorkflowNode_ToolConfig struct {
	// ToolConfig for tool nodes
	ToolConfig *ToolNodeConfig `protobuf:"bytes,6,opt,name=tool_config,json=toolConfig,proto3,oneof"`
}

type WorkflowNode_PluginConfig struct {
	// PluginConfig for plugin nodes
	PluginConfig *PluginNodeConfig `protobuf:"bytes,7,opt,name=plugin_config,json=pluginConfig,proto3,oneof"`
}

type WorkflowNode_ConditionConfig struct {
	// ConditionConfig for condition nodes
	ConditionConfig *ConditionNodeConfig `protobuf:"bytes,8,opt,name=condition_config,json=conditionConfig,proto3,oneof"`
}

type WorkflowNode_ParallelConfig struct {
	// ParallelConfig for parallel nodes
	ParallelConfig *ParallelNodeConfig `protobuf:"bytes,9,opt,name=parallel_config,json=parallelConfig,proto3,oneof"`
}

func (*WorkflowNode_AgentConfig) isWorkflowNode_Config() {}

func (*WorkflowNode_ToolConfig) isWorkflowNode_Config() {}

func (*WorkflowNode_PluginConfig) isWorkflowNode_Config() {}

func (*WorkflowNode_ConditionConfig) isWorkflowNode_Config() {}

func (*WorkflowNode_ParallelConfig) isWorkflowNode_Config() {}

// AgentNodeConfig contains configuration for agent nodes
type AgentNodeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// AgentName is the name of the agent to execute
	AgentName string `protobuf:"bytes,1,opt,name=agent_name,json=agentName,proto3" json:"agent_name,omitempty"`
	// Task is the agent task configuration
	Task          *proto.Task `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentNodeConfig) Reset() {
	*x = AgentNodeConfig{}
	mi := &file_workflow_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentNodeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentNodeConfig) ProtoMessage() {}

func (x *AgentNodeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentNodeConfig.ProtoReflect.Descriptor instead.
func (*AgentNodeConfig) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{3}
}

func (x *AgentNodeConfig) GetAgentName() string {
	if x != nil {
		return x.AgentName
	}
	return ""
}

func (x *AgentNodeConfig) GetTask() *proto.Task {
	if x != nil {
		return x.Task
	}
	return nil
}

// ToolNodeConfig contains configuration for tool nodes
type ToolNodeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ToolName is the name of the tool to execute
	ToolName string `protobuf:"bytes,1,opt,name=tool_name,json=toolName,proto3" json:"tool_name,omitempty"`
	// Input contains the tool input parameters
	Input         map[string]string `protobuf:"bytes,2,rep,name=input,proto3" json:"input,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolNodeConfig) Reset() {
	*x = ToolNodeConfig{}
	mi := &file_workflow_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolNodeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolNodeConfig) ProtoMessage() {}

func (x *ToolNodeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolNodeConfig.ProtoReflect.Descriptor instead.
func (*ToolNodeConfig) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{4}
}

func (x *ToolNodeConfig) GetToolName() string {
	if x != nil {
		return x.ToolName
	}
	return ""
}

func (x *ToolNodeConfig) GetInput() map[string]string {
	if x != nil {
		return x.Input
	}
	return nil
}

// PluginNodeConfig contains configuration for plugin nodes
type PluginNodeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// PluginName is the name of the plugin to query
	PluginName string `protobuf:"bytes,1,opt,name=plugin_name,json=pluginName,proto3" json:"plugin_name,omitempty"`
	// Method is the plugin method to call
	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	// Params contains the method parameters
	Params        map[string]string `protobuf:"bytes,3,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginNodeConfig) Reset() {
	*x = PluginNodeConfig{}
	mi := &file_workflow_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginNodeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginNodeConfig) ProtoMessage() {}

func (x *PluginNodeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginNodeConfig.ProtoReflect.Descriptor instead.
func (*PluginNodeConfig) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{5}
}

func (x *PluginNodeConfig) GetPluginName() string {
	if x != nil {
		return x.PluginName
	}
	return ""
}

func (x *PluginNodeConfig) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *PluginNodeConfig) GetParams() map[string]string {
	if x != nil {
		return x.Params
	}
	return nil
}

// ConditionNodeConfig contains configuration for condition nodes
type ConditionNodeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Expression to evaluate (e.g., "result.status == 'success'")
	Expression string `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	// TrueBranch contains node IDs to execute if condition is true
	TrueBranch []string `protobuf:"bytes,2,rep,name=true_branch,json=trueBranch,proto3" json:"true_branch,omitempty"`
	// FalseBranch contains node IDs to execute if condition is false
	FalseBranch   []string `protobuf:"bytes,3,rep,name=false_branch,json=falseBranch,proto3" json:"false_branch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConditionNodeConfig) Reset() {
	*x = ConditionNodeConfig{}
	mi := &file_workflow_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConditionNodeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConditionNodeConfig) ProtoMessage() {}

func (x *ConditionNodeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConditionNodeConfig.ProtoReflect.Descriptor instead.
func (*ConditionNodeConfig) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{6}
}

func (x *ConditionNodeConfig) GetExpression() string {
	if x != nil {
		return x.Expression
	}
	return ""
}

func (x *ConditionNodeConfig) GetTrueBranch() []string {
	if x != nil {
		return x.TrueBranch
	}
	return nil
}

func (x *ConditionNodeConfig) GetFalseBranch() []string {
	if x != nil {
		return x.FalseBranch
	}
	return nil
}

// ParallelNodeConfig contains configuration for parallel nodes
type ParallelNodeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SubNodes contains the nodes to execute in parallel
	SubNodes []*WorkflowNode `protobuf:"bytes,1,rep,name=sub_nodes,json=subNodes,proto3" json:"sub_nodes,omitempty"`
	// MaxConcurrency limits the number of concurrent executions (0 = unlimited)
	MaxConcurrency int32 `protobuf:"varint,2,opt,name=max_concurrency,json=maxConcurrency,proto3" json:"max_concurrency,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ParallelNodeConfig) Reset() {
	*x = ParallelNodeConfig{}
	mi := &file_workflow_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParallelNodeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParallelNodeConfig) ProtoMessage() {}

func (x *ParallelNodeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParallelNodeConfig.ProtoReflect.Descriptor instead.
func (*ParallelNodeConfig) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{7}
}

func (x *ParallelNodeConfig) GetSubNodes() []*WorkflowNode {
	if x != nil {
		return x.SubNodes
	}
	return nil
}

func (x *ParallelNodeConfig) GetMaxConcurrency() int32 {
	if x != nil {
		return x.MaxConcurrency
	}
	return 0
}

// RetryPolicy defines the retry behavior for a workflow node
type RetryPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// MaxRetries is the maximum number of retry attempts
	MaxRetries int32 `protobuf:"varint,1,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	// BackoffStrategy determines how delays are calculated between retries
	BackoffStrategy BackoffStrategy `protobuf:"varint,2,opt,name=backoff_strategy,json=backoffStrategy,proto3,enum=gibson.workflow.BackoffStrategy" json:"backoff_strategy,omitempty"`
	// InitialDelay is the delay before the first retry attempt
	InitialDelay *durationpb.Duration `protobuf:"bytes,3,opt,name=initial_delay,json=initialDelay,proto3" json:"initial_delay,omitempty"`
	// MaxDelay is the maximum delay between retry attempts (used for exponential backoff)
	MaxDelay *durationpb.Duration `protobuf:"bytes,4,opt,name=max_delay,json=maxDelay,proto3" json:"max_delay,omitempty"`
	// Multiplier is the factor by which the delay increases (used for exponential backoff)
	Multiplier    float64 `protobuf:"fixed64,5,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RetryPolicy) Reset() {
	*x = RetryPolicy{}
	mi := &file_workflow_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetryPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetryPolicy) ProtoMessage() {}

func (x *RetryPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetryPolicy.ProtoReflect.Descriptor instead.
func (*RetryPolicy) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{8}
}

func (x *RetryPolicy) GetMaxRetries() int32 {
	if x != nil {
		return x.MaxRetries
	}
	return 0
}

func (x *RetryPolicy) GetBackoffStrategy() BackoffStrategy {
	if x != nil {
		return x.BackoffStrategy
	}
	return BackoffStrategy_BACKOFF_STRATEGY_UNSPECIFIED
}

func (x *RetryPolicy) GetInitialDelay() *durationpb.Duration {
	if x != nil {
		return x.InitialDelay
	}
	return nil
}

func (x *RetryPolicy) GetMaxDelay() *durationpb.Duration {
	if x != nil {
		return x.MaxDelay
	}
	return nil
}

func (x *RetryPolicy) GetMultiplier() float64 {
	if x != nil {
		return x.Multiplier
	}
	return 0
}

// DataPolicy defines how data is handled for a node
type DataPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// StoreInput determines whether to store input data in GraphRAG
	StoreInput bool `protobuf:"varint,1,opt,name=store_input,json=storeInput,proto3" json:"store_input,omitempty"`
	// StoreOutput determines whether to store output data in GraphRAG
	StoreOutput bool `protobuf:"varint,2,opt,name=store_output,json=storeOutput,proto3" json:"store_output,omitempty"`
	// Retention specifies how long to retain data (0 = forever)
	Retention *durationpb.Duration `protobuf:"bytes,3,opt,name=retention,proto3" json:"retention,omitempty"`
	// Encryption determines whether data should be encrypted at rest
	Encryption bool `protobuf:"varint,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// AccessControl specifies who can access this data
	AccessControl []string `protobuf:"bytes,5,rep,name=access_control,json=accessControl,proto3" json:"access_control,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataPolicy) Reset() {
	*x = DataPolicy{}
	mi := &file_workflow_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataPolicy) ProtoMessage() {}

func (x *DataPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataPolicy.ProtoReflect.Descriptor instead.
func (*DataPolicy) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{9}
}

func (x *DataPolicy) GetStoreInput() bool {
	if x != nil {
		return x.StoreInput
	}
	return false
}

func (x *DataPolicy) GetStoreOutput() bool {
	if x != nil {
		return x.StoreOutput
	}
	return false
}

func (x *DataPolicy) GetRetention() *durationpb.Duration {
	if x != nil {
		return x.Retention
	}
	return nil
}

func (x *DataPolicy) GetEncryption() bool {
	if x != nil {
		return x.Encryption
	}
	return false
}

func (x *DataPolicy) GetAccessControl() []string {
	if x != nil {
		return x.AccessControl
	}
	return nil
}

// WorkflowEdge represents a directed edge in the workflow DAG
type WorkflowEdge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// From is the source node ID
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// To is the destination node ID
	To string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	// Condition is an optional condition that must be satisfied for the edge to be traversed
	Condition string `protobuf:"bytes,3,opt,name=condition,proto3" json:"condition,omitempty"`
	// Metadata contains additional metadata for the edge
	Metadata      map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowEdge) Reset() {
	*x = WorkflowEdge{}
	mi := &file_workflow_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowEdge) ProtoMessage() {}

func (x *WorkflowEdge) ProtoReflect() protoreflect.Message {
	mi := &file_workflow_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowEdge.ProtoReflect.Descriptor instead.
func (*WorkflowEdge) Descriptor() ([]byte, []int) {
	return file_workflow_proto_rawDescGZIP(), []int{10}
}

func (x *WorkflowEdge) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *WorkflowEdge) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *WorkflowEdge) GetCondition() string {
	if x != nil {
		return x.Condition
	}
	return ""
}

func (x *WorkflowEdge) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

var File_workflow_proto protoreflect.FileDescriptor

const file_workflow_proto_rawDesc = "" +
	"\n" +
	"\x0eworkflow.proto\x12\x0fgibson.workflow\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\vtypes.proto\"\x94\x06\n" +
	"\x12WorkflowDefinition\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12\x1d\n" +
	"\n" +
	"target_ref\x18\x05 \x01(\tR\ttargetRef\x12D\n" +
	"\x05nodes\x18\x06 \x03(\v2..gibson.workflow.WorkflowDefinition.NodesEntryR\x05nodes\x123\n" +
	"\x05edges\x18\a \x03(\v2\x1d.gibson.workflow.WorkflowEdgeR\x05edges\x12!\n" +
	"\fentry_points\x18\b \x03(\tR\ventryPoints\x12\x1f\n" +
	"\vexit_points\x18\t \x03(\tR\n" +
	"exitPoints\x12M\n" +
	"\bmetadata\x18\n" +
	" \x03(\v21.gibson.workflow.WorkflowDefinition.MetadataEntryR\bmetadata\x12I\n" +
	"\fdependencies\x18\v \x01(\v2%.gibson.workflow.WorkflowDependenciesR\fdependencies\x12\x16\n" +
	"\x06source\x18\f \x01(\tR\x06source\x12=\n" +
	"\finstalled_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\vinstalledAt\x129\n" +
	"\n" +
	"created_at\x18\x0e \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x1aW\n" +
	"\n" +
	"NodesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.gibson.workflow.WorkflowNodeR\x05value:\x028\x01\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"^\n" +
	"\x14WorkflowDependencies\x12\x16\n" +
	"\x06agents\x18\x01 \x03(\tR\x06agents\x12\x14\n" +
	"\x05tools\x18\x02 \x03(\tR\x05tools\x12\x18\n" +
	"\aplugins\x18\x03 \x03(\tR\aplugins\"\xe3\x06\n" +
	"\fWorkflowNode\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12-\n" +
	"\x04type\x18\x02 \x01(\x0e2\x19.gibson.workflow.NodeTypeR\x04type\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12E\n" +
	"\fagent_config\x18\x05 \x01(\v2 .gibson.workflow.AgentNodeConfigH\x00R\vagentConfig\x12B\n" +
	"\vtool_config\x18\x06 \x01(\v2\x1f.gibson.workflow.ToolNodeConfigH\x00R\n" +
	"toolConfig\x12H\n" +
	"\rplugin_config\x18\a \x01(\v2!.gibson.workflow.PluginNodeConfigH\x00R\fpluginConfig\x12Q\n" +
	"\x10condition_config\x18\b \x01(\v2$.gibson.workflow.ConditionNodeConfigH\x00R\x0fconditionConfig\x12N\n" +
	"\x0fparallel_config\x18\t \x01(\v2#.gibson.workflow.ParallelNodeConfigH\x00R\x0eparallelConfig\x12\"\n" +
	"\fdependencies\x18\n" +
	" \x03(\tR\fdependencies\x123\n" +
	"\atimeout\x18\v \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12?\n" +
	"\fretry_policy\x18\f \x01(\v2\x1c.gibson.workflow.RetryPolicyR\vretryPolicy\x12<\n" +
	"\vdata_policy\x18\r \x01(\v2\x1b.gibson.workflow.DataPolicyR\n" +
	"dataPolicy\x12G\n" +
	"\bmetadata\x18\x0e \x03(\v2+.gibson.workflow.WorkflowNode.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\b\n" +
	"\x06config\"X\n" +
	"\x0fAgentNodeConfig\x12\x1d\n" +
	"\n" +
	"agent_name\x18\x01 \x01(\tR\tagentName\x12&\n" +
	"\x04task\x18\x02 \x01(\v2\x12.gibson.types.TaskR\x04task\"\xa9\x01\n" +
	"\x0eToolNodeConfig\x12\x1b\n" +
	"\ttool_name\x18\x01 \x01(\tR\btoolName\x12@\n" +
	"\x05input\x18\x02 \x03(\v2*.gibson.workflow.ToolNodeConfig.InputEntryR\x05input\x1a8\n" +
	"\n" +
	"InputEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xcd\x01\n" +
	"\x10PluginNodeConfig\x12\x1f\n" +
	"\vplugin_name\x18\x01 \x01(\tR\n" +
	"pluginName\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12E\n" +
	"\x06params\x18\x03 \x03(\v2-.gibson.workflow.PluginNodeConfig.ParamsEntryR\x06params\x1a9\n" +
	"\vParamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"y\n" +
	"\x13ConditionNodeConfig\x12\x1e\n" +
	"\n" +
	"expression\x18\x01 \x01(\tR\n" +
	"expression\x12\x1f\n" +
	"\vtrue_branch\x18\x02 \x03(\tR\n" +
	"trueBranch\x12!\n" +
	"\ffalse_branch\x18\x03 \x03(\tR\vfalseBranch\"y\n" +
	"\x12ParallelNodeConfig\x12:\n" +
	"\tsub_nodes\x18\x01 \x03(\v2\x1d.gibson.workflow.WorkflowNodeR\bsubNodes\x12'\n" +
	"\x0fmax_concurrency\x18\x02 \x01(\x05R\x0emaxConcurrency\"\x93\x02\n" +
	"\vRetryPolicy\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\x05R\n" +
	"maxRetries\x12K\n" +
	"\x10backoff_strategy\x18\x02 \x01(\x0e2 .gibson.workflow.BackoffStrategyR\x0fbackoffStrategy\x12>\n" +
	"\rinitial_delay\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\finitialDelay\x126\n" +
	"\tmax_delay\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\bmaxDelay\x12\x1e\n" +
	"\n" +
	"multiplier\x18\x05 \x01(\x01R\n" +
	"multiplier\"\xd0\x01\n" +
	"\n" +
	"DataPolicy\x12\x1f\n" +
	"\vstore_input\x18\x01 \x01(\bR\n" +
	"storeInput\x12!\n" +
	"\fstore_output\x18\x02 \x01(\bR\vstoreOutput\x127\n" +
	"\tretention\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\tretention\x12\x1e\n" +
	"\n" +
	"encryption\x18\x04 \x01(\bR\n" +
	"encryption\x12%\n" +
	"\x0eaccess_control\x18\x05 \x03(\tR\raccessControl\"\xd6\x01\n" +
	"\fWorkflowEdge\x12\x12\n" +
	"\x04from\x18\x01 \x01(\tR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x01(\tR\x02to\x12\x1c\n" +
	"\tcondition\x18\x03 \x01(\tR\tcondition\x12G\n" +
	"\bmetadata\x18\x04 \x03(\v2+.gibson.workflow.WorkflowEdge.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\xa9\x01\n" +
	"\bNodeType\x12\x19\n" +
	"\x15NODE_TYPE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fNODE_TYPE_AGENT\x10\x01\x12\x12\n" +
	"\x0eNODE_TYPE_TOOL\x10\x02\x12\x14\n" +
	"\x10NODE_TYPE_PLUGIN\x10\x03\x12\x17\n" +
	"\x13NODE_TYPE_CONDITION\x10\x04\x12\x16\n" +
	"\x12NODE_TYPE_PARALLEL\x10\x05\x12\x12\n" +
	"\x0eNODE_TYPE_JOIN\x10\x06*\x91\x01\n" +
	"\x0fBackoffStrategy\x12 \n" +
	"\x1cBACKOFF_STRATEGY_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19BACKOFF_STRATEGY_CONSTANT\x10\x01\x12\x1b\n" +
	"\x17BACKOFF_STRATEGY_LINEAR\x10\x02\x12 \n" +
	"\x1cBACKOFF_STRATEGY_EXPONENTIAL\x10\x03B/Z-github.com/zero-day-ai/sdk/api/gen/workflowpbb\x06proto3"

var (
	file_workflow_proto_rawDescOnce sync.Once
	file_workflow_proto_rawDescData []byte
)

func file_workflow_proto_rawDescGZIP() []byte {
	file_workflow_proto_rawDescOnce.Do(func() {
		file_workflow_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_workflow_proto_rawDesc), len(file_workflow_proto_rawDesc)))
	})
	return file_workflow_proto_rawDescData
}

var file_workflow_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_workflow_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_workflow_proto_goTypes = []any{
	(NodeType)(0),                 // 0: gibson.workflow.NodeType
	(BackoffStrategy)(0),          // 1: gibson.workflow.BackoffStrategy
	(*WorkflowDefinition)(nil),    // 2: gibson.workflow.WorkflowDefinition
	(*WorkflowDependencies)(nil),  // 3: gibson.workflow.WorkflowDependencies
	(*WorkflowNode)(nil),          // 4: gibson.workflow.WorkflowNode
	(*AgentNodeConfig)(nil),       // 5: gibson.workflow.AgentNodeConfig
	(*ToolNodeConfig)(nil),        // 6: gibson.workflow.ToolNodeConfig
	(*PluginNodeConfig)(nil),      // 7: gibson.workflow.PluginNodeConfig
	(*ConditionNodeConfig)(nil),   // 8: gibson.workflow.ConditionNodeConfig
	(*ParallelNodeConfig)(nil),    // 9: gibson.workflow.ParallelNodeConfig
	(*RetryPolicy)(nil),           // 10: gibson.workflow.RetryPolicy
	(*DataPolicy)(nil),            // 11: gibson.workflow.DataPolicy
	(*WorkflowEdge)(nil),          // 12: gibson.workflow.WorkflowEdge
	nil,                           // 13: gibson.workflow.WorkflowDefinition.NodesEntry
	nil,                           // 14: gibson.workflow.WorkflowDefinition.MetadataEntry
	nil,                           // 15: gibson.workflow.WorkflowNode.MetadataEntry
	nil,                           // 16: gibson.workflow.ToolNodeConfig.InputEntry
	nil,                           // 17: gibson.workflow.PluginNodeConfig.ParamsEntry
	nil,                           // 18: gibson.workflow.WorkflowEdge.MetadataEntry
	(*timestamppb.Timestamp)(nil), // 19: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),   // 20: google.protobuf.Duration
	(*proto.Task)(nil),            // 21: gibson.types.Task
}
var file_workflow_proto_depIdxs = []int32{
	13, // 0: gibson.workflow.WorkflowDefinition.nodes:type_name -> gibson.workflow.WorkflowDefinition.NodesEntry
	12, // 1: gibson.workflow.WorkflowDefinition.edges:type_name -> gibson.workflow.WorkflowEdge
	14, // 2: gibson.workflow.WorkflowDefinition.metadata:type_name -> gibson.workflow.WorkflowDefinition.MetadataEntry
	3,  // 3: gibson.workflow.WorkflowDefinition.dependencies:type_name -> gibson.workflow.WorkflowDependencies
	19, // 4: gibson.workflow.WorkflowDefinition.installed_at:type_name -> google.protobuf.Timestamp
	19, // 5: gibson.workflow.WorkflowDefinition.created_at:type_name -> google.protobuf.Timestamp
	0,  // 6: gibson.workflow.WorkflowNode.type:type_name -> gibson.workflow.NodeType
	5,  // 7: gibson.workflow.WorkflowNode.agent_config:type_name -> gibson.workflow.AgentNodeConfig
	6,  // 8: gibson.workflow.WorkflowNode.tool_config:type_name -> gibson.workflow.ToolNodeConfig
	7,  // 9: gibson.workflow.WorkflowNode.plugin_config:type_name -> gibson.workflow.PluginNodeConfig
	8,  // 10: gibson.workflow.WorkflowNode.condition_config:type_name -> gibson.workflow.ConditionNodeConfig
	9,  // 11: gibson.workflow.WorkflowNode.parallel_config:type_name -> gibson.workflow.ParallelNodeConfig
	20, // 12: gibson.workflow.WorkflowNode.timeout:type_name -> google.protobuf.Duration
	10, // 13: gibson.workflow.WorkflowNode.retry_policy:type_name -> gibson.workflow.RetryPolicy
	11, // 14: gibson.workflow.WorkflowNode.data_policy:type_name -> gibson.workflow.DataPolicy
	15, // 15: gibson.workflow.WorkflowNode.metadata:type_name -> gibson.workflow.WorkflowNode.MetadataEntry
	21, // 16: gibson.workflow.AgentNodeConfig.task:type_name -> gibson.types.Task
	16, // 17: gibson.workflow.ToolNodeConfig.input:type_name -> gibson.workflow.ToolNodeConfig.InputEntry
	17, // 18: gibson.workflow.PluginNodeConfig.params:type_name -> gibson.workflow.PluginNodeConfig.ParamsEntry
	4,  // 19: gibson.workflow.ParallelNodeConfig.sub_nodes:type_name -> gibson.workflow.WorkflowNode
	1,  // 20: gibson.workflow.RetryPolicy.backoff_strategy:type_name -> gibson.workflow.BackoffStrategy
	20, // 21: gibson.workflow.RetryPolicy.initial_delay:type_name -> google.protobuf.Duration
	20, // 22: gibson.workflow.RetryPolicy.max_delay:type_name -> google.protobuf.Duration
	20, // 23: gibson.workflow.DataPolicy.retention:type_name -> google.protobuf.Duration
	18, // 24: gibson.workflow.WorkflowEdge.metadata:type_name -> gibson.workflow.WorkflowEdge.MetadataEntry
	4,  // 25: gibson.workflow.WorkflowDefinition.NodesEntry.value:type_name -> gibson.workflow.WorkflowNode
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_workflow_proto_init() }
func file_workflow_proto_init() {
	if File_workflow_proto != nil {
		return
	}
	file_workflow_proto_msgTypes[2].OneofWrappers = []any{
		(*WorkflowNode_AgentConfig)(nil),
		(*WorkflowNode_ToolConfig)(nil),
		(*WorkflowNode_PluginConfig)(nil),
		(*WorkflowNode_ConditionConfig)(nil),
		(*WorkflowNode_ParallelConfig)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_workflow_proto_rawDesc), len(file_workflow_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_workflow_proto_goTypes,
		DependencyIndexes: file_workflow_proto_depIdxs,
		EnumInfos:         file_workflow_proto_enumTypes,
		MessageInfos:      file_workflow_proto_msgTypes,
	}.Build()
	File_workflow_proto = out.File
	file_workflow_proto_goTypes = nil
	file_workflow_proto_depIdxs = nil
}
