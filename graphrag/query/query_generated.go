// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: taxonomy/core.yaml
// Taxonomy Version: 3.0.0
// Generated at: 2026-01-25T15:29:23Z

package query

import (
	"context"
	"fmt"

	"github.com/zero-day-ai/sdk/api/gen/taxonomypb"
)

// ==================== QUERY BUILDERS ====================

// ==================== Mission Query ====================

// MissionQuery provides type-safe query building for mission nodes.
type MissionQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Missions creates a new MissionQuery.
func Missions(client GraphClient) *MissionQuery {
	return &MissionQuery{
		client: client,
	}
}

// Where methods for each property

// WhereName adds a predicate on the name property.
func (q *MissionQuery) WhereName(op Op, value string) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereTarget adds a predicate on the target property.
func (q *MissionQuery) WhereTarget(op Op, value string) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "target",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStatus adds a predicate on the status property.
func (q *MissionQuery) WhereStatus(op Op, value string) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStatusIn adds an IN predicate for status enum values.
func (q *MissionQuery) WhereStatusIn(values ...string) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereDescription adds a predicate on the description property.
func (q *MissionQuery) WhereDescription(op Op, value string) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "description",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStartedAt adds a predicate on the started_at property.
func (q *MissionQuery) WhereStartedAt(op Op, value int64) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "started_at",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCompletedAt adds a predicate on the completed_at property.
func (q *MissionQuery) WhereCompletedAt(op Op, value int64) *MissionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "completed_at",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// WithMissionRun traverses the HAS_RUN relationship to mission_run nodes.
func (q *MissionQuery) WithMissionRun() *MissionQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_RUN",
		TargetType:   "mission_run",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *MissionQuery) FromAgentRunViaDiscovered() *MissionQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching mission nodes.
func (q *MissionQuery) All(ctx context.Context) ([]*taxonomypb.Mission, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Mission, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToMission(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching mission node.
func (q *MissionQuery) First(ctx context.Context) (*taxonomypb.Mission, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no mission found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching mission nodes.
func (q *MissionQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *MissionQuery) Limit(n int) *MissionQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *MissionQuery) Offset(n int) *MissionQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this mission query.
func (q *MissionQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Mission", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this mission query.
func (q *MissionQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Mission", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToMission parses a raw query result into a Mission proto.
func parseNodeToMission(result map[string]any) (*taxonomypb.Mission, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Mission{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["name"]; ok {
		if s, ok := val.(string); ok {
			node.Name = s
		}
	}
	if val, ok := nodeData["target"]; ok {
		if s, ok := val.(string); ok {
			node.Target = s
		}
	}
	if val, ok := nodeData["status"]; ok {
		if s, ok := val.(string); ok {
			node.Status = &s
		}
	}
	if val, ok := nodeData["description"]; ok {
		if s, ok := val.(string); ok {
			node.Description = &s
		}
	}
	if val, ok := nodeData["started_at"]; ok {
		if t, ok := val.(int64); ok {
			node.StartedAt = &t
		}
	}
	if val, ok := nodeData["completed_at"]; ok {
		if t, ok := val.(int64); ok {
			node.CompletedAt = &t
		}
	}

	return node, nil
}

// ==================== MissionRun Query ====================

// MissionRunQuery provides type-safe query building for mission_run nodes.
type MissionRunQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// MissionRuns creates a new MissionRunQuery.
func MissionRuns(client GraphClient) *MissionRunQuery {
	return &MissionRunQuery{
		client: client,
	}
}

// Where methods for each property

// WhereRunNumber adds a predicate on the run_number property.
func (q *MissionRunQuery) WhereRunNumber(op Op, value int32) *MissionRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "run_number",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStatus adds a predicate on the status property.
func (q *MissionRunQuery) WhereStatus(op Op, value string) *MissionRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStatusIn adds an IN predicate for status enum values.
func (q *MissionRunQuery) WhereStatusIn(values ...string) *MissionRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereStartedAt adds a predicate on the started_at property.
func (q *MissionRunQuery) WhereStartedAt(op Op, value int64) *MissionRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "started_at",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCompletedAt adds a predicate on the completed_at property.
func (q *MissionRunQuery) WhereCompletedAt(op Op, value int64) *MissionRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "completed_at",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// ContainsAgentRun traverses the CONTAINS_AGENT_RUN relationship to agent_run nodes.
func (q *MissionRunQuery) ContainsAgentRun() *MissionRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "CONTAINS_AGENT_RUN",
		TargetType:   "agent_run",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromMissionViaHasRun traverses the HAS_RUN relationship from mission nodes.
func (q *MissionRunQuery) FromMissionViaHasRun() *MissionRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_RUN",
		TargetType:   "mission",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *MissionRunQuery) FromAgentRunViaDiscovered() *MissionRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching mission_run nodes.
func (q *MissionRunQuery) All(ctx context.Context) ([]*taxonomypb.MissionRun, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.MissionRun, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToMissionRun(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching mission_run node.
func (q *MissionRunQuery) First(ctx context.Context) (*taxonomypb.MissionRun, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no mission_run found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching mission_run nodes.
func (q *MissionRunQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *MissionRunQuery) Limit(n int) *MissionRunQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *MissionRunQuery) Offset(n int) *MissionRunQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this mission_run query.
func (q *MissionRunQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("MissionRun", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this mission_run query.
func (q *MissionRunQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("MissionRun", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToMissionRun parses a raw query result into a MissionRun proto.
func parseNodeToMissionRun(result map[string]any) (*taxonomypb.MissionRun, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.MissionRun{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["run_number"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.RunNumber = i32
		}
	}
	if val, ok := nodeData["status"]; ok {
		if s, ok := val.(string); ok {
			node.Status = &s
		}
	}
	if val, ok := nodeData["started_at"]; ok {
		if t, ok := val.(int64); ok {
			node.StartedAt = &t
		}
	}
	if val, ok := nodeData["completed_at"]; ok {
		if t, ok := val.(int64); ok {
			node.CompletedAt = &t
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_mission_id"].(string); ok {
		node.ParentMissionId = parentId
	}

	return node, nil
}

// ==================== AgentRun Query ====================

// AgentRunQuery provides type-safe query building for agent_run nodes.
type AgentRunQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// AgentRuns creates a new AgentRunQuery.
func AgentRuns(client GraphClient) *AgentRunQuery {
	return &AgentRunQuery{
		client: client,
	}
}

// Where methods for each property

// WhereAgentName adds a predicate on the agent_name property.
func (q *AgentRunQuery) WhereAgentName(op Op, value string) *AgentRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "agent_name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStatus adds a predicate on the status property.
func (q *AgentRunQuery) WhereStatus(op Op, value string) *AgentRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStatusIn adds an IN predicate for status enum values.
func (q *AgentRunQuery) WhereStatusIn(values ...string) *AgentRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereStartedAt adds a predicate on the started_at property.
func (q *AgentRunQuery) WhereStartedAt(op Op, value int64) *AgentRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "started_at",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCompletedAt adds a predicate on the completed_at property.
func (q *AgentRunQuery) WhereCompletedAt(op Op, value int64) *AgentRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "completed_at",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereErrorMessage adds a predicate on the error_message property.
func (q *AgentRunQuery) WhereErrorMessage(op Op, value string) *AgentRunQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "error_message",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// ExecutedTool traverses the EXECUTED_TOOL relationship to tool_execution nodes.
func (q *AgentRunQuery) ExecutedTool() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "EXECUTED_TOOL",
		TargetType:   "tool_execution",
		Direction:    "out",
	})
	return q
}

// MadeCall traverses the MADE_CALL relationship to llm_call nodes.
func (q *AgentRunQuery) MadeCall() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "MADE_CALL",
		TargetType:   "llm_call",
		Direction:    "out",
	})
	return q
}

// DelegatedTo traverses the DELEGATED_TO relationship to agent_run nodes.
func (q *AgentRunQuery) DelegatedTo() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DELEGATED_TO",
		TargetType:   "agent_run",
		Direction:    "out",
	})
	return q
}

// Discovered traverses the DISCOVERED relationship to GraphNode nodes.
func (q *AgentRunQuery) Discovered() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "GraphNode",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromMissionRunViaContainsAgentRun traverses the CONTAINS_AGENT_RUN relationship from mission_run nodes.
func (q *AgentRunQuery) FromMissionRunViaContainsAgentRun() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "CONTAINS_AGENT_RUN",
		TargetType:   "mission_run",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDelegatedTo traverses the DELEGATED_TO relationship from agent_run nodes.
func (q *AgentRunQuery) FromAgentRunViaDelegatedTo() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DELEGATED_TO",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *AgentRunQuery) FromAgentRunViaDiscovered() *AgentRunQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching agent_run nodes.
func (q *AgentRunQuery) All(ctx context.Context) ([]*taxonomypb.AgentRun, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.AgentRun, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToAgentRun(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching agent_run node.
func (q *AgentRunQuery) First(ctx context.Context) (*taxonomypb.AgentRun, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no agent_run found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching agent_run nodes.
func (q *AgentRunQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *AgentRunQuery) Limit(n int) *AgentRunQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *AgentRunQuery) Offset(n int) *AgentRunQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this agent_run query.
func (q *AgentRunQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("AgentRun", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this agent_run query.
func (q *AgentRunQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("AgentRun", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToAgentRun parses a raw query result into a AgentRun proto.
func parseNodeToAgentRun(result map[string]any) (*taxonomypb.AgentRun, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.AgentRun{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["agent_name"]; ok {
		if s, ok := val.(string); ok {
			node.AgentName = s
		}
	}
	if val, ok := nodeData["status"]; ok {
		if s, ok := val.(string); ok {
			node.Status = &s
		}
	}
	if val, ok := nodeData["started_at"]; ok {
		if t, ok := val.(int64); ok {
			node.StartedAt = &t
		}
	}
	if val, ok := nodeData["completed_at"]; ok {
		if t, ok := val.(int64); ok {
			node.CompletedAt = &t
		}
	}
	if val, ok := nodeData["error_message"]; ok {
		if s, ok := val.(string); ok {
			node.ErrorMessage = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_mission_run_id"].(string); ok {
		node.ParentMissionRunId = parentId
	}

	return node, nil
}

// ==================== ToolExecution Query ====================

// ToolExecutionQuery provides type-safe query building for tool_execution nodes.
type ToolExecutionQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// ToolExecutions creates a new ToolExecutionQuery.
func ToolExecutions(client GraphClient) *ToolExecutionQuery {
	return &ToolExecutionQuery{
		client: client,
	}
}

// Where methods for each property

// WhereToolName adds a predicate on the tool_name property.
func (q *ToolExecutionQuery) WhereToolName(op Op, value string) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "tool_name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCommand adds a predicate on the command property.
func (q *ToolExecutionQuery) WhereCommand(op Op, value string) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "command",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereExitCode adds a predicate on the exit_code property.
func (q *ToolExecutionQuery) WhereExitCode(op Op, value int32) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "exit_code",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStartedAt adds a predicate on the started_at property.
func (q *ToolExecutionQuery) WhereStartedAt(op Op, value int64) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "started_at",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCompletedAt adds a predicate on the completed_at property.
func (q *ToolExecutionQuery) WhereCompletedAt(op Op, value int64) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "completed_at",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStdout adds a predicate on the stdout property.
func (q *ToolExecutionQuery) WhereStdout(op Op, value string) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "stdout",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStderr adds a predicate on the stderr property.
func (q *ToolExecutionQuery) WhereStderr(op Op, value string) *ToolExecutionQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "stderr",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Inbound Traversals ---

// FromAgentRunViaExecutedTool traverses the EXECUTED_TOOL relationship from agent_run nodes.
func (q *ToolExecutionQuery) FromAgentRunViaExecutedTool() *ToolExecutionQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "EXECUTED_TOOL",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *ToolExecutionQuery) FromAgentRunViaDiscovered() *ToolExecutionQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching tool_execution nodes.
func (q *ToolExecutionQuery) All(ctx context.Context) ([]*taxonomypb.ToolExecution, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.ToolExecution, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToToolExecution(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching tool_execution node.
func (q *ToolExecutionQuery) First(ctx context.Context) (*taxonomypb.ToolExecution, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no tool_execution found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching tool_execution nodes.
func (q *ToolExecutionQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *ToolExecutionQuery) Limit(n int) *ToolExecutionQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *ToolExecutionQuery) Offset(n int) *ToolExecutionQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this tool_execution query.
func (q *ToolExecutionQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("ToolExecution", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this tool_execution query.
func (q *ToolExecutionQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("ToolExecution", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToToolExecution parses a raw query result into a ToolExecution proto.
func parseNodeToToolExecution(result map[string]any) (*taxonomypb.ToolExecution, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.ToolExecution{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["tool_name"]; ok {
		if s, ok := val.(string); ok {
			node.ToolName = s
		}
	}
	if val, ok := nodeData["command"]; ok {
		if s, ok := val.(string); ok {
			node.Command = &s
		}
	}
	if val, ok := nodeData["exit_code"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.ExitCode = &i32
		}
	}
	if val, ok := nodeData["started_at"]; ok {
		if t, ok := val.(int64); ok {
			node.StartedAt = &t
		}
	}
	if val, ok := nodeData["completed_at"]; ok {
		if t, ok := val.(int64); ok {
			node.CompletedAt = &t
		}
	}
	if val, ok := nodeData["stdout"]; ok {
		if s, ok := val.(string); ok {
			node.Stdout = &s
		}
	}
	if val, ok := nodeData["stderr"]; ok {
		if s, ok := val.(string); ok {
			node.Stderr = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_agent_run_id"].(string); ok {
		node.ParentAgentRunId = parentId
	}

	return node, nil
}

// ==================== LlmCall Query ====================

// LlmCallQuery provides type-safe query building for llm_call nodes.
type LlmCallQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// LlmCalls creates a new LlmCallQuery.
func LlmCalls(client GraphClient) *LlmCallQuery {
	return &LlmCallQuery{
		client: client,
	}
}

// Where methods for each property

// WhereModel adds a predicate on the model property.
func (q *LlmCallQuery) WhereModel(op Op, value string) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "model",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereProvider adds a predicate on the provider property.
func (q *LlmCallQuery) WhereProvider(op Op, value string) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "provider",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereSlotName adds a predicate on the slot_name property.
func (q *LlmCallQuery) WhereSlotName(op Op, value string) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "slot_name",
		Op:    op,
		Value: value,
	})
	return q
}

// WherePromptTokens adds a predicate on the prompt_tokens property.
func (q *LlmCallQuery) WherePromptTokens(op Op, value int32) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "prompt_tokens",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCompletionTokens adds a predicate on the completion_tokens property.
func (q *LlmCallQuery) WhereCompletionTokens(op Op, value int32) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "completion_tokens",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereTotalTokens adds a predicate on the total_tokens property.
func (q *LlmCallQuery) WhereTotalTokens(op Op, value int32) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "total_tokens",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereLatencyMs adds a predicate on the latency_ms property.
func (q *LlmCallQuery) WhereLatencyMs(op Op, value int64) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "latency_ms",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStartedAt adds a predicate on the started_at property.
func (q *LlmCallQuery) WhereStartedAt(op Op, value int64) *LlmCallQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "started_at",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Inbound Traversals ---

// FromAgentRunViaMadeCall traverses the MADE_CALL relationship from agent_run nodes.
func (q *LlmCallQuery) FromAgentRunViaMadeCall() *LlmCallQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "MADE_CALL",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *LlmCallQuery) FromAgentRunViaDiscovered() *LlmCallQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching llm_call nodes.
func (q *LlmCallQuery) All(ctx context.Context) ([]*taxonomypb.LlmCall, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.LlmCall, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToLlmCall(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching llm_call node.
func (q *LlmCallQuery) First(ctx context.Context) (*taxonomypb.LlmCall, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no llm_call found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching llm_call nodes.
func (q *LlmCallQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *LlmCallQuery) Limit(n int) *LlmCallQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *LlmCallQuery) Offset(n int) *LlmCallQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this llm_call query.
func (q *LlmCallQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("LlmCall", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this llm_call query.
func (q *LlmCallQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("LlmCall", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToLlmCall parses a raw query result into a LlmCall proto.
func parseNodeToLlmCall(result map[string]any) (*taxonomypb.LlmCall, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.LlmCall{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["model"]; ok {
		if s, ok := val.(string); ok {
			node.Model = s
		}
	}
	if val, ok := nodeData["provider"]; ok {
		if s, ok := val.(string); ok {
			node.Provider = &s
		}
	}
	if val, ok := nodeData["slot_name"]; ok {
		if s, ok := val.(string); ok {
			node.SlotName = &s
		}
	}
	if val, ok := nodeData["prompt_tokens"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.PromptTokens = &i32
		}
	}
	if val, ok := nodeData["completion_tokens"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.CompletionTokens = &i32
		}
	}
	if val, ok := nodeData["total_tokens"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.TotalTokens = &i32
		}
	}
	if val, ok := nodeData["latency_ms"]; ok {
		if i, ok := val.(int64); ok {
			node.LatencyMs = &i
		}
	}
	if val, ok := nodeData["started_at"]; ok {
		if t, ok := val.(int64); ok {
			node.StartedAt = &t
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_agent_run_id"].(string); ok {
		node.ParentAgentRunId = parentId
	}

	return node, nil
}

// ==================== Domain Query ====================

// DomainQuery provides type-safe query building for domain nodes.
type DomainQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Domains creates a new DomainQuery.
func Domains(client GraphClient) *DomainQuery {
	return &DomainQuery{
		client: client,
	}
}

// Where methods for each property

// WhereName adds a predicate on the name property.
func (q *DomainQuery) WhereName(op Op, value string) *DomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereRegistrar adds a predicate on the registrar property.
func (q *DomainQuery) WhereRegistrar(op Op, value string) *DomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "registrar",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCreatedDate adds a predicate on the created_date property.
func (q *DomainQuery) WhereCreatedDate(op Op, value int64) *DomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "created_date",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereExpiryDate adds a predicate on the expiry_date property.
func (q *DomainQuery) WhereExpiryDate(op Op, value int64) *DomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "expiry_date",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereNameservers adds a predicate on the nameservers property.
func (q *DomainQuery) WhereNameservers(op Op, value string) *DomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "nameservers",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// WithSubdomain traverses the HAS_SUBDOMAIN relationship to subdomain nodes.
func (q *DomainQuery) WithSubdomain() *DomainQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_SUBDOMAIN",
		TargetType:   "subdomain",
		Direction:    "out",
	})
	return q
}

// ResolvesTo traverses the RESOLVES_TO relationship to host nodes.
func (q *DomainQuery) ResolvesTo() *DomainQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "RESOLVES_TO",
		TargetType:   "host",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *DomainQuery) FromAgentRunViaDiscovered() *DomainQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching domain nodes.
func (q *DomainQuery) All(ctx context.Context) ([]*taxonomypb.Domain, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Domain, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToDomain(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching domain node.
func (q *DomainQuery) First(ctx context.Context) (*taxonomypb.Domain, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no domain found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching domain nodes.
func (q *DomainQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *DomainQuery) Limit(n int) *DomainQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *DomainQuery) Offset(n int) *DomainQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this domain query.
func (q *DomainQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Domain", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this domain query.
func (q *DomainQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Domain", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToDomain parses a raw query result into a Domain proto.
func parseNodeToDomain(result map[string]any) (*taxonomypb.Domain, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Domain{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["name"]; ok {
		if s, ok := val.(string); ok {
			node.Name = s
		}
	}
	if val, ok := nodeData["registrar"]; ok {
		if s, ok := val.(string); ok {
			node.Registrar = &s
		}
	}
	if val, ok := nodeData["created_date"]; ok {
		if t, ok := val.(int64); ok {
			node.CreatedDate = &t
		}
	}
	if val, ok := nodeData["expiry_date"]; ok {
		if t, ok := val.(int64); ok {
			node.ExpiryDate = &t
		}
	}
	if val, ok := nodeData["nameservers"]; ok {
		if s, ok := val.(string); ok {
			node.Nameservers = &s
		}
	}

	return node, nil
}

// ==================== Subdomain Query ====================

// SubdomainQuery provides type-safe query building for subdomain nodes.
type SubdomainQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Subdomains creates a new SubdomainQuery.
func Subdomains(client GraphClient) *SubdomainQuery {
	return &SubdomainQuery{
		client: client,
	}
}

// Where methods for each property

// WhereName adds a predicate on the name property.
func (q *SubdomainQuery) WhereName(op Op, value string) *SubdomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereFullName adds a predicate on the full_name property.
func (q *SubdomainQuery) WhereFullName(op Op, value string) *SubdomainQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "full_name",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// ResolvesTo traverses the RESOLVES_TO relationship to host nodes.
func (q *SubdomainQuery) ResolvesTo() *SubdomainQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "RESOLVES_TO",
		TargetType:   "host",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromDomainViaHasSubdomain traverses the HAS_SUBDOMAIN relationship from domain nodes.
func (q *SubdomainQuery) FromDomainViaHasSubdomain() *SubdomainQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_SUBDOMAIN",
		TargetType:   "domain",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *SubdomainQuery) FromAgentRunViaDiscovered() *SubdomainQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching subdomain nodes.
func (q *SubdomainQuery) All(ctx context.Context) ([]*taxonomypb.Subdomain, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Subdomain, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToSubdomain(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching subdomain node.
func (q *SubdomainQuery) First(ctx context.Context) (*taxonomypb.Subdomain, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no subdomain found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching subdomain nodes.
func (q *SubdomainQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *SubdomainQuery) Limit(n int) *SubdomainQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *SubdomainQuery) Offset(n int) *SubdomainQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this subdomain query.
func (q *SubdomainQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Subdomain", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this subdomain query.
func (q *SubdomainQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Subdomain", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToSubdomain parses a raw query result into a Subdomain proto.
func parseNodeToSubdomain(result map[string]any) (*taxonomypb.Subdomain, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Subdomain{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["name"]; ok {
		if s, ok := val.(string); ok {
			node.Name = s
		}
	}
	if val, ok := nodeData["full_name"]; ok {
		if s, ok := val.(string); ok {
			node.FullName = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_domain_id"].(string); ok {
		node.ParentDomainId = parentId
	}

	return node, nil
}

// ==================== Host Query ====================

// HostQuery provides type-safe query building for host nodes.
type HostQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Hosts creates a new HostQuery.
func Hosts(client GraphClient) *HostQuery {
	return &HostQuery{
		client: client,
	}
}

// Where methods for each property

// WhereIp adds a predicate on the ip property.
func (q *HostQuery) WhereIp(op Op, value string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "ip",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereHostname adds a predicate on the hostname property.
func (q *HostQuery) WhereHostname(op Op, value string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "hostname",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereOs adds a predicate on the os property.
func (q *HostQuery) WhereOs(op Op, value string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "os",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereOsVersion adds a predicate on the os_version property.
func (q *HostQuery) WhereOsVersion(op Op, value string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "os_version",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereMacAddress adds a predicate on the mac_address property.
func (q *HostQuery) WhereMacAddress(op Op, value string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "mac_address",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereState adds a predicate on the state property.
func (q *HostQuery) WhereState(op Op, value string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "state",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStateIn adds an IN predicate for state enum values.
func (q *HostQuery) WhereStateIn(values ...string) *HostQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "state",
		Op:    In,
		Value: values,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// WithPort traverses the HAS_PORT relationship to port nodes.
func (q *HostQuery) WithPort() *HostQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_PORT",
		TargetType:   "port",
		Direction:    "out",
	})
	return q
}

// UsesTechnology traverses the USES_TECHNOLOGY relationship to technology nodes.
func (q *HostQuery) UsesTechnology() *HostQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "USES_TECHNOLOGY",
		TargetType:   "technology",
		Direction:    "out",
	})
	return q
}

// ServesCertificate traverses the SERVES_CERTIFICATE relationship to certificate nodes.
func (q *HostQuery) ServesCertificate() *HostQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "SERVES_CERTIFICATE",
		TargetType:   "certificate",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromDomainViaResolvesTo traverses the RESOLVES_TO relationship from domain nodes.
func (q *HostQuery) FromDomainViaResolvesTo() *HostQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "RESOLVES_TO",
		TargetType:   "domain",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *HostQuery) FromAgentRunViaDiscovered() *HostQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaAffects traverses the AFFECTS relationship from finding nodes.
func (q *HostQuery) FromFindingViaAffects() *HostQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "AFFECTS",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching host nodes.
func (q *HostQuery) All(ctx context.Context) ([]*taxonomypb.Host, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Host, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToHost(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching host node.
func (q *HostQuery) First(ctx context.Context) (*taxonomypb.Host, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no host found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching host nodes.
func (q *HostQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *HostQuery) Limit(n int) *HostQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *HostQuery) Offset(n int) *HostQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this host query.
func (q *HostQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Host", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this host query.
func (q *HostQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Host", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToHost parses a raw query result into a Host proto.
func parseNodeToHost(result map[string]any) (*taxonomypb.Host, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Host{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["ip"]; ok {
		if s, ok := val.(string); ok {
			node.Ip = &s
		}
	}
	if val, ok := nodeData["hostname"]; ok {
		if s, ok := val.(string); ok {
			node.Hostname = &s
		}
	}
	if val, ok := nodeData["os"]; ok {
		if s, ok := val.(string); ok {
			node.Os = &s
		}
	}
	if val, ok := nodeData["os_version"]; ok {
		if s, ok := val.(string); ok {
			node.OsVersion = &s
		}
	}
	if val, ok := nodeData["mac_address"]; ok {
		if s, ok := val.(string); ok {
			node.MacAddress = &s
		}
	}
	if val, ok := nodeData["state"]; ok {
		if s, ok := val.(string); ok {
			node.State = &s
		}
	}

	return node, nil
}

// ==================== Port Query ====================

// PortQuery provides type-safe query building for port nodes.
type PortQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Ports creates a new PortQuery.
func Ports(client GraphClient) *PortQuery {
	return &PortQuery{
		client: client,
	}
}

// Where methods for each property

// WhereNumber adds a predicate on the number property.
func (q *PortQuery) WhereNumber(op Op, value int32) *PortQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "number",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereProtocol adds a predicate on the protocol property.
func (q *PortQuery) WhereProtocol(op Op, value string) *PortQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "protocol",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereProtocolIn adds an IN predicate for protocol enum values.
func (q *PortQuery) WhereProtocolIn(values ...string) *PortQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "protocol",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereState adds a predicate on the state property.
func (q *PortQuery) WhereState(op Op, value string) *PortQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "state",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereStateIn adds an IN predicate for state enum values.
func (q *PortQuery) WhereStateIn(values ...string) *PortQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "state",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereReason adds a predicate on the reason property.
func (q *PortQuery) WhereReason(op Op, value string) *PortQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "reason",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// WithService traverses the RUNS_SERVICE relationship to service nodes.
func (q *PortQuery) WithService() *PortQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "RUNS_SERVICE",
		TargetType:   "service",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromHostViaHasPort traverses the HAS_PORT relationship from host nodes.
func (q *PortQuery) FromHostViaHasPort() *PortQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_PORT",
		TargetType:   "host",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *PortQuery) FromAgentRunViaDiscovered() *PortQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaAffects traverses the AFFECTS relationship from finding nodes.
func (q *PortQuery) FromFindingViaAffects() *PortQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "AFFECTS",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching port nodes.
func (q *PortQuery) All(ctx context.Context) ([]*taxonomypb.Port, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Port, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToPort(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching port node.
func (q *PortQuery) First(ctx context.Context) (*taxonomypb.Port, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no port found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching port nodes.
func (q *PortQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *PortQuery) Limit(n int) *PortQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *PortQuery) Offset(n int) *PortQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this port query.
func (q *PortQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Port", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this port query.
func (q *PortQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Port", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToPort parses a raw query result into a Port proto.
func parseNodeToPort(result map[string]any) (*taxonomypb.Port, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Port{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["number"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.Number = i32
		}
	}
	if val, ok := nodeData["protocol"]; ok {
		if s, ok := val.(string); ok {
			node.Protocol = s
		}
	}
	if val, ok := nodeData["state"]; ok {
		if s, ok := val.(string); ok {
			node.State = &s
		}
	}
	if val, ok := nodeData["reason"]; ok {
		if s, ok := val.(string); ok {
			node.Reason = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_host_id"].(string); ok {
		node.ParentHostId = parentId
	}

	return node, nil
}

// ==================== Service Query ====================

// ServiceQuery provides type-safe query building for service nodes.
type ServiceQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Services creates a new ServiceQuery.
func Services(client GraphClient) *ServiceQuery {
	return &ServiceQuery{
		client: client,
	}
}

// Where methods for each property

// WhereName adds a predicate on the name property.
func (q *ServiceQuery) WhereName(op Op, value string) *ServiceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereProduct adds a predicate on the product property.
func (q *ServiceQuery) WhereProduct(op Op, value string) *ServiceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "product",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereVersion adds a predicate on the version property.
func (q *ServiceQuery) WhereVersion(op Op, value string) *ServiceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "version",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereExtraInfo adds a predicate on the extra_info property.
func (q *ServiceQuery) WhereExtraInfo(op Op, value string) *ServiceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "extra_info",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereBanner adds a predicate on the banner property.
func (q *ServiceQuery) WhereBanner(op Op, value string) *ServiceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "banner",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCpe adds a predicate on the cpe property.
func (q *ServiceQuery) WhereCpe(op Op, value string) *ServiceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "cpe",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// WithEndpoint traverses the HAS_ENDPOINT relationship to endpoint nodes.
func (q *ServiceQuery) WithEndpoint() *ServiceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_ENDPOINT",
		TargetType:   "endpoint",
		Direction:    "out",
	})
	return q
}

// UsesTechnology traverses the USES_TECHNOLOGY relationship to technology nodes.
func (q *ServiceQuery) UsesTechnology() *ServiceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "USES_TECHNOLOGY",
		TargetType:   "technology",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromPortViaRunsService traverses the RUNS_SERVICE relationship from port nodes.
func (q *ServiceQuery) FromPortViaRunsService() *ServiceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "RUNS_SERVICE",
		TargetType:   "port",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *ServiceQuery) FromAgentRunViaDiscovered() *ServiceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaAffects traverses the AFFECTS relationship from finding nodes.
func (q *ServiceQuery) FromFindingViaAffects() *ServiceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "AFFECTS",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching service nodes.
func (q *ServiceQuery) All(ctx context.Context) ([]*taxonomypb.Service, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Service, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToService(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching service node.
func (q *ServiceQuery) First(ctx context.Context) (*taxonomypb.Service, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no service found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching service nodes.
func (q *ServiceQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *ServiceQuery) Limit(n int) *ServiceQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *ServiceQuery) Offset(n int) *ServiceQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this service query.
func (q *ServiceQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Service", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this service query.
func (q *ServiceQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Service", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToService parses a raw query result into a Service proto.
func parseNodeToService(result map[string]any) (*taxonomypb.Service, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Service{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["name"]; ok {
		if s, ok := val.(string); ok {
			node.Name = s
		}
	}
	if val, ok := nodeData["product"]; ok {
		if s, ok := val.(string); ok {
			node.Product = &s
		}
	}
	if val, ok := nodeData["version"]; ok {
		if s, ok := val.(string); ok {
			node.Version = &s
		}
	}
	if val, ok := nodeData["extra_info"]; ok {
		if s, ok := val.(string); ok {
			node.ExtraInfo = &s
		}
	}
	if val, ok := nodeData["banner"]; ok {
		if s, ok := val.(string); ok {
			node.Banner = &s
		}
	}
	if val, ok := nodeData["cpe"]; ok {
		if s, ok := val.(string); ok {
			node.Cpe = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_port_id"].(string); ok {
		node.ParentPortId = parentId
	}

	return node, nil
}

// ==================== Endpoint Query ====================

// EndpointQuery provides type-safe query building for endpoint nodes.
type EndpointQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Endpoints creates a new EndpointQuery.
func Endpoints(client GraphClient) *EndpointQuery {
	return &EndpointQuery{
		client: client,
	}
}

// Where methods for each property

// WhereUrl adds a predicate on the url property.
func (q *EndpointQuery) WhereUrl(op Op, value string) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "url",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereMethod adds a predicate on the method property.
func (q *EndpointQuery) WhereMethod(op Op, value string) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "method",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereMethodIn adds an IN predicate for method enum values.
func (q *EndpointQuery) WhereMethodIn(values ...string) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "method",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereStatusCode adds a predicate on the status_code property.
func (q *EndpointQuery) WhereStatusCode(op Op, value int32) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "status_code",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereContentType adds a predicate on the content_type property.
func (q *EndpointQuery) WhereContentType(op Op, value string) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "content_type",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereContentLength adds a predicate on the content_length property.
func (q *EndpointQuery) WhereContentLength(op Op, value int64) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "content_length",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereTitle adds a predicate on the title property.
func (q *EndpointQuery) WhereTitle(op Op, value string) *EndpointQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "title",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// UsesTechnology traverses the USES_TECHNOLOGY relationship to technology nodes.
func (q *EndpointQuery) UsesTechnology() *EndpointQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "USES_TECHNOLOGY",
		TargetType:   "technology",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromServiceViaHasEndpoint traverses the HAS_ENDPOINT relationship from service nodes.
func (q *EndpointQuery) FromServiceViaHasEndpoint() *EndpointQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_ENDPOINT",
		TargetType:   "service",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *EndpointQuery) FromAgentRunViaDiscovered() *EndpointQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaAffects traverses the AFFECTS relationship from finding nodes.
func (q *EndpointQuery) FromFindingViaAffects() *EndpointQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "AFFECTS",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching endpoint nodes.
func (q *EndpointQuery) All(ctx context.Context) ([]*taxonomypb.Endpoint, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Endpoint, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToEndpoint(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching endpoint node.
func (q *EndpointQuery) First(ctx context.Context) (*taxonomypb.Endpoint, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no endpoint found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching endpoint nodes.
func (q *EndpointQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *EndpointQuery) Limit(n int) *EndpointQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *EndpointQuery) Offset(n int) *EndpointQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this endpoint query.
func (q *EndpointQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Endpoint", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this endpoint query.
func (q *EndpointQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Endpoint", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToEndpoint parses a raw query result into a Endpoint proto.
func parseNodeToEndpoint(result map[string]any) (*taxonomypb.Endpoint, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Endpoint{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["url"]; ok {
		if s, ok := val.(string); ok {
			node.Url = s
		}
	}
	if val, ok := nodeData["method"]; ok {
		if s, ok := val.(string); ok {
			node.Method = &s
		}
	}
	if val, ok := nodeData["status_code"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.StatusCode = &i32
		}
	}
	if val, ok := nodeData["content_type"]; ok {
		if s, ok := val.(string); ok {
			node.ContentType = &s
		}
	}
	if val, ok := nodeData["content_length"]; ok {
		if i, ok := val.(int64); ok {
			node.ContentLength = &i
		}
	}
	if val, ok := nodeData["title"]; ok {
		if s, ok := val.(string); ok {
			node.Title = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_service_id"].(string); ok {
		node.ParentServiceId = parentId
	}

	return node, nil
}

// ==================== Technology Query ====================

// TechnologyQuery provides type-safe query building for technology nodes.
type TechnologyQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Technologies creates a new TechnologyQuery.
func Technologies(client GraphClient) *TechnologyQuery {
	return &TechnologyQuery{
		client: client,
	}
}

// Where methods for each property

// WhereName adds a predicate on the name property.
func (q *TechnologyQuery) WhereName(op Op, value string) *TechnologyQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereVersion adds a predicate on the version property.
func (q *TechnologyQuery) WhereVersion(op Op, value string) *TechnologyQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "version",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCategory adds a predicate on the category property.
func (q *TechnologyQuery) WhereCategory(op Op, value string) *TechnologyQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "category",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereConfidence adds a predicate on the confidence property.
func (q *TechnologyQuery) WhereConfidence(op Op, value int32) *TechnologyQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "confidence",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCpe adds a predicate on the cpe property.
func (q *TechnologyQuery) WhereCpe(op Op, value string) *TechnologyQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "cpe",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Inbound Traversals ---

// FromHostViaUsesTechnology traverses the USES_TECHNOLOGY relationship from host nodes.
func (q *TechnologyQuery) FromHostViaUsesTechnology() *TechnologyQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "USES_TECHNOLOGY",
		TargetType:   "host",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *TechnologyQuery) FromAgentRunViaDiscovered() *TechnologyQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaAffects traverses the AFFECTS relationship from finding nodes.
func (q *TechnologyQuery) FromFindingViaAffects() *TechnologyQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "AFFECTS",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching technology nodes.
func (q *TechnologyQuery) All(ctx context.Context) ([]*taxonomypb.Technology, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Technology, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToTechnology(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching technology node.
func (q *TechnologyQuery) First(ctx context.Context) (*taxonomypb.Technology, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no technology found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching technology nodes.
func (q *TechnologyQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *TechnologyQuery) Limit(n int) *TechnologyQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *TechnologyQuery) Offset(n int) *TechnologyQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this technology query.
func (q *TechnologyQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Technology", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this technology query.
func (q *TechnologyQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Technology", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToTechnology parses a raw query result into a Technology proto.
func parseNodeToTechnology(result map[string]any) (*taxonomypb.Technology, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Technology{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["name"]; ok {
		if s, ok := val.(string); ok {
			node.Name = s
		}
	}
	if val, ok := nodeData["version"]; ok {
		if s, ok := val.(string); ok {
			node.Version = &s
		}
	}
	if val, ok := nodeData["category"]; ok {
		if s, ok := val.(string); ok {
			node.Category = &s
		}
	}
	if val, ok := nodeData["confidence"]; ok {
		if i, ok := val.(int64); ok {
			i32 := int32(i)
			node.Confidence = &i32
		}
	}
	if val, ok := nodeData["cpe"]; ok {
		if s, ok := val.(string); ok {
			node.Cpe = &s
		}
	}

	return node, nil
}

// ==================== Certificate Query ====================

// CertificateQuery provides type-safe query building for certificate nodes.
type CertificateQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Certificates creates a new CertificateQuery.
func Certificates(client GraphClient) *CertificateQuery {
	return &CertificateQuery{
		client: client,
	}
}

// Where methods for each property

// WhereSubject adds a predicate on the subject property.
func (q *CertificateQuery) WhereSubject(op Op, value string) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "subject",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereIssuer adds a predicate on the issuer property.
func (q *CertificateQuery) WhereIssuer(op Op, value string) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "issuer",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereSerialNumber adds a predicate on the serial_number property.
func (q *CertificateQuery) WhereSerialNumber(op Op, value string) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "serial_number",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereNotBefore adds a predicate on the not_before property.
func (q *CertificateQuery) WhereNotBefore(op Op, value int64) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "not_before",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereNotAfter adds a predicate on the not_after property.
func (q *CertificateQuery) WhereNotAfter(op Op, value int64) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "not_after",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereFingerprintSha256 adds a predicate on the fingerprint_sha256 property.
func (q *CertificateQuery) WhereFingerprintSha256(op Op, value string) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "fingerprint_sha256",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereSan adds a predicate on the san property.
func (q *CertificateQuery) WhereSan(op Op, value string) *CertificateQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "san",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Inbound Traversals ---

// FromHostViaServesCertificate traverses the SERVES_CERTIFICATE relationship from host nodes.
func (q *CertificateQuery) FromHostViaServesCertificate() *CertificateQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "SERVES_CERTIFICATE",
		TargetType:   "host",
		Direction:    "in",
	})
	return q
}

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *CertificateQuery) FromAgentRunViaDiscovered() *CertificateQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching certificate nodes.
func (q *CertificateQuery) All(ctx context.Context) ([]*taxonomypb.Certificate, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Certificate, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToCertificate(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching certificate node.
func (q *CertificateQuery) First(ctx context.Context) (*taxonomypb.Certificate, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no certificate found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching certificate nodes.
func (q *CertificateQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *CertificateQuery) Limit(n int) *CertificateQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *CertificateQuery) Offset(n int) *CertificateQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this certificate query.
func (q *CertificateQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Certificate", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this certificate query.
func (q *CertificateQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Certificate", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToCertificate parses a raw query result into a Certificate proto.
func parseNodeToCertificate(result map[string]any) (*taxonomypb.Certificate, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Certificate{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["subject"]; ok {
		if s, ok := val.(string); ok {
			node.Subject = &s
		}
	}
	if val, ok := nodeData["issuer"]; ok {
		if s, ok := val.(string); ok {
			node.Issuer = &s
		}
	}
	if val, ok := nodeData["serial_number"]; ok {
		if s, ok := val.(string); ok {
			node.SerialNumber = &s
		}
	}
	if val, ok := nodeData["not_before"]; ok {
		if t, ok := val.(int64); ok {
			node.NotBefore = &t
		}
	}
	if val, ok := nodeData["not_after"]; ok {
		if t, ok := val.(int64); ok {
			node.NotAfter = &t
		}
	}
	if val, ok := nodeData["fingerprint_sha256"]; ok {
		if s, ok := val.(string); ok {
			node.FingerprintSha256 = &s
		}
	}
	if val, ok := nodeData["san"]; ok {
		if s, ok := val.(string); ok {
			node.San = &s
		}
	}

	return node, nil
}

// ==================== Finding Query ====================

// FindingQuery provides type-safe query building for finding nodes.
type FindingQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Findings creates a new FindingQuery.
func Findings(client GraphClient) *FindingQuery {
	return &FindingQuery{
		client: client,
	}
}

// Where methods for each property

// WhereTitle adds a predicate on the title property.
func (q *FindingQuery) WhereTitle(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "title",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereDescription adds a predicate on the description property.
func (q *FindingQuery) WhereDescription(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "description",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereSeverity adds a predicate on the severity property.
func (q *FindingQuery) WhereSeverity(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "severity",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereSeverityIn adds an IN predicate for severity enum values.
func (q *FindingQuery) WhereSeverityIn(values ...string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "severity",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereConfidence adds a predicate on the confidence property.
func (q *FindingQuery) WhereConfidence(op Op, value float64) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "confidence",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCategory adds a predicate on the category property.
func (q *FindingQuery) WhereCategory(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "category",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereSubcategory adds a predicate on the subcategory property.
func (q *FindingQuery) WhereSubcategory(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "subcategory",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereRemediation adds a predicate on the remediation property.
func (q *FindingQuery) WhereRemediation(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "remediation",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCvssScore adds a predicate on the cvss_score property.
func (q *FindingQuery) WhereCvssScore(op Op, value float64) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "cvss_score",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCveIds adds a predicate on the cve_ids property.
func (q *FindingQuery) WhereCveIds(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "cve_ids",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereCweIds adds a predicate on the cwe_ids property.
func (q *FindingQuery) WhereCweIds(op Op, value string) *FindingQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "cwe_ids",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Outbound Traversals ---

// Affects traverses the AFFECTS relationship to host nodes.
func (q *FindingQuery) Affects() *FindingQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "AFFECTS",
		TargetType:   "host",
		Direction:    "out",
	})
	return q
}

// WithEvidence traverses the HAS_EVIDENCE relationship to evidence nodes.
func (q *FindingQuery) WithEvidence() *FindingQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_EVIDENCE",
		TargetType:   "evidence",
		Direction:    "out",
	})
	return q
}

// UsesTechnique traverses the USES_TECHNIQUE relationship to technique nodes.
func (q *FindingQuery) UsesTechnique() *FindingQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "USES_TECHNIQUE",
		TargetType:   "technique",
		Direction:    "out",
	})
	return q
}

// LeadsTo traverses the LEADS_TO relationship to finding nodes.
func (q *FindingQuery) LeadsTo() *FindingQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "LEADS_TO",
		TargetType:   "finding",
		Direction:    "out",
	})
	return q
}

// --- Inbound Traversals ---

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *FindingQuery) FromAgentRunViaDiscovered() *FindingQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaLeadsTo traverses the LEADS_TO relationship from finding nodes.
func (q *FindingQuery) FromFindingViaLeadsTo() *FindingQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "LEADS_TO",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching finding nodes.
func (q *FindingQuery) All(ctx context.Context) ([]*taxonomypb.Finding, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Finding, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToFinding(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching finding node.
func (q *FindingQuery) First(ctx context.Context) (*taxonomypb.Finding, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no finding found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching finding nodes.
func (q *FindingQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *FindingQuery) Limit(n int) *FindingQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *FindingQuery) Offset(n int) *FindingQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this finding query.
func (q *FindingQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Finding", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this finding query.
func (q *FindingQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Finding", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToFinding parses a raw query result into a Finding proto.
func parseNodeToFinding(result map[string]any) (*taxonomypb.Finding, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Finding{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["title"]; ok {
		if s, ok := val.(string); ok {
			node.Title = s
		}
	}
	if val, ok := nodeData["description"]; ok {
		if s, ok := val.(string); ok {
			node.Description = &s
		}
	}
	if val, ok := nodeData["severity"]; ok {
		if s, ok := val.(string); ok {
			node.Severity = s
		}
	}
	if val, ok := nodeData["confidence"]; ok {
		if f, ok := val.(float64); ok {
			node.Confidence = &f
		}
	}
	if val, ok := nodeData["category"]; ok {
		if s, ok := val.(string); ok {
			node.Category = &s
		}
	}
	if val, ok := nodeData["subcategory"]; ok {
		if s, ok := val.(string); ok {
			node.Subcategory = &s
		}
	}
	if val, ok := nodeData["remediation"]; ok {
		if s, ok := val.(string); ok {
			node.Remediation = &s
		}
	}
	if val, ok := nodeData["cvss_score"]; ok {
		if f, ok := val.(float64); ok {
			node.CvssScore = &f
		}
	}
	if val, ok := nodeData["cve_ids"]; ok {
		if s, ok := val.(string); ok {
			node.CveIds = &s
		}
	}
	if val, ok := nodeData["cwe_ids"]; ok {
		if s, ok := val.(string); ok {
			node.CweIds = &s
		}
	}

	return node, nil
}

// ==================== Evidence Query ====================

// EvidenceQuery provides type-safe query building for evidence nodes.
type EvidenceQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Evidences creates a new EvidenceQuery.
func Evidences(client GraphClient) *EvidenceQuery {
	return &EvidenceQuery{
		client: client,
	}
}

// Where methods for each property

// WhereType adds a predicate on the type property.
func (q *EvidenceQuery) WhereType(op Op, value string) *EvidenceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "type",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereTypeIn adds an IN predicate for type enum values.
func (q *EvidenceQuery) WhereTypeIn(values ...string) *EvidenceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "type",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereContent adds a predicate on the content property.
func (q *EvidenceQuery) WhereContent(op Op, value string) *EvidenceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "content",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereContentType adds a predicate on the content_type property.
func (q *EvidenceQuery) WhereContentType(op Op, value string) *EvidenceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "content_type",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereUrl adds a predicate on the url property.
func (q *EvidenceQuery) WhereUrl(op Op, value string) *EvidenceQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "url",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Inbound Traversals ---

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *EvidenceQuery) FromAgentRunViaDiscovered() *EvidenceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaHasEvidence traverses the HAS_EVIDENCE relationship from finding nodes.
func (q *EvidenceQuery) FromFindingViaHasEvidence() *EvidenceQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "HAS_EVIDENCE",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching evidence nodes.
func (q *EvidenceQuery) All(ctx context.Context) ([]*taxonomypb.Evidence, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Evidence, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToEvidence(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching evidence node.
func (q *EvidenceQuery) First(ctx context.Context) (*taxonomypb.Evidence, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no evidence found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching evidence nodes.
func (q *EvidenceQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *EvidenceQuery) Limit(n int) *EvidenceQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *EvidenceQuery) Offset(n int) *EvidenceQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this evidence query.
func (q *EvidenceQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Evidence", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this evidence query.
func (q *EvidenceQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Evidence", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToEvidence parses a raw query result into a Evidence proto.
func parseNodeToEvidence(result map[string]any) (*taxonomypb.Evidence, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Evidence{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["type"]; ok {
		if s, ok := val.(string); ok {
			node.Type = s
		}
	}
	if val, ok := nodeData["content"]; ok {
		if s, ok := val.(string); ok {
			node.Content = &s
		}
	}
	if val, ok := nodeData["content_type"]; ok {
		if s, ok := val.(string); ok {
			node.ContentType = &s
		}
	}
	if val, ok := nodeData["url"]; ok {
		if s, ok := val.(string); ok {
			node.Url = &s
		}
	}
	// Parse parent reference
	if parentId, ok := nodeData["parent_finding_id"].(string); ok {
		node.ParentFindingId = parentId
	}

	return node, nil
}

// ==================== Technique Query ====================

// TechniqueQuery provides type-safe query building for technique nodes.
type TechniqueQuery struct {
	predicates []Predicate
	traversals []Traversal
	client     GraphClient
	limit      int
	offset     int
}

// Techniques creates a new TechniqueQuery.
func Techniques(client GraphClient) *TechniqueQuery {
	return &TechniqueQuery{
		client: client,
	}
}

// Where methods for each property

// WhereTechniqueId adds a predicate on the technique_id property.
func (q *TechniqueQuery) WhereTechniqueId(op Op, value string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "technique_id",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereName adds a predicate on the name property.
func (q *TechniqueQuery) WhereName(op Op, value string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "name",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereTaxonomy adds a predicate on the taxonomy property.
func (q *TechniqueQuery) WhereTaxonomy(op Op, value string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "taxonomy",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereTaxonomyIn adds an IN predicate for taxonomy enum values.
func (q *TechniqueQuery) WhereTaxonomyIn(values ...string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "taxonomy",
		Op:    In,
		Value: values,
	})
	return q
}

// WhereTactic adds a predicate on the tactic property.
func (q *TechniqueQuery) WhereTactic(op Op, value string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "tactic",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereDescription adds a predicate on the description property.
func (q *TechniqueQuery) WhereDescription(op Op, value string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "description",
		Op:    op,
		Value: value,
	})
	return q
}

// WhereUrl adds a predicate on the url property.
func (q *TechniqueQuery) WhereUrl(op Op, value string) *TechniqueQuery {
	q.predicates = append(q.predicates, Predicate{
		Field: "url",
		Op:    op,
		Value: value,
	})
	return q
}

// Traversal methods for relationships

// --- Inbound Traversals ---

// FromAgentRunViaDiscovered traverses the DISCOVERED relationship from agent_run nodes.
func (q *TechniqueQuery) FromAgentRunViaDiscovered() *TechniqueQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "DISCOVERED",
		TargetType:   "agent_run",
		Direction:    "in",
	})
	return q
}

// FromFindingViaUsesTechnique traverses the USES_TECHNIQUE relationship from finding nodes.
func (q *TechniqueQuery) FromFindingViaUsesTechnique() *TechniqueQuery {
	q.traversals = append(q.traversals, Traversal{
		Relationship: "USES_TECHNIQUE",
		TargetType:   "finding",
		Direction:    "in",
	})
	return q
}

// Terminal methods

// All executes the query and returns all matching technique nodes.
func (q *TechniqueQuery) All(ctx context.Context) ([]*taxonomypb.Technique, error) {
	cypher, params := q.buildCypher()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	nodes := make([]*taxonomypb.Technique, 0, len(results))
	for _, result := range results {
		node, err := parseNodeToTechnique(result)
		if err != nil {
			return nil, fmt.Errorf("failed to parse result: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// First executes the query and returns the first matching technique node.
func (q *TechniqueQuery) First(ctx context.Context) (*taxonomypb.Technique, error) {
	q.limit = 1
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, fmt.Errorf("no technique found")
	}
	return nodes[0], nil
}

// Count executes the query and returns the count of matching technique nodes.
func (q *TechniqueQuery) Count(ctx context.Context) (int, error) {
	cypher, params := q.buildCypherCount()

	results, err := q.client.Query(ctx, cypher, params)
	if err != nil {
		return 0, fmt.Errorf("count query failed: %w", err)
	}

	if len(results) == 0 {
		return 0, nil
	}

	count, ok := results[0]["count"].(int64)
	if !ok {
		return 0, fmt.Errorf("invalid count result")
	}

	return int(count), nil
}

// Limit sets the maximum number of results to return.
func (q *TechniqueQuery) Limit(n int) *TechniqueQuery {
	q.limit = n
	return q
}

// Offset sets the number of results to skip.
func (q *TechniqueQuery) Offset(n int) *TechniqueQuery {
	q.offset = n
	return q
}

// buildCypher builds the Cypher query for this technique query.
func (q *TechniqueQuery) buildCypher() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Technique", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause

		// Add return clause
		cypher += " " + BuildReturn(alias, nil)

		// Add pagination
		if q.limit > 0 {
			cypher += fmt.Sprintf(" LIMIT %d", q.limit)
		}
		if q.offset > 0 {
			cypher += fmt.Sprintf(" SKIP %d", q.offset)
		}

		return cypher, params
	}

	// No predicates - just return
	cypher += " " + BuildReturn(alias, nil)

	// Add pagination
	if q.limit > 0 {
		cypher += fmt.Sprintf(" LIMIT %d", q.limit)
	}
	if q.offset > 0 {
		cypher += fmt.Sprintf(" SKIP %d", q.offset)
	}

	return cypher, nil
}

// buildCypherCount builds the COUNT Cypher query for this technique query.
func (q *TechniqueQuery) buildCypherCount() (string, map[string]any) {
	alias := "n"
	cypher := BuildMatch("Technique", alias)

	// Add traversals
	for i, trav := range q.traversals {
		travAlias := fmt.Sprintf("t%d", i)
		cypher += " " + BuildTraversal(trav, alias, travAlias)
	}

	// Add predicates
	if len(q.predicates) > 0 {
		whereClause, params := BuildWhere(q.predicates, alias)
		cypher += " " + whereClause + " RETURN count(" + alias + ") as count"
		return cypher, params
	}

	cypher += " RETURN count(" + alias + ") as count"
	return cypher, nil
}

// parseNodeToTechnique parses a raw query result into a Technique proto.
func parseNodeToTechnique(result map[string]any) (*taxonomypb.Technique, error) {
	nodeData, ok := result["n"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid node data")
	}

	node := &taxonomypb.Technique{}

	// Parse ID
	if id, ok := nodeData["id"].(string); ok {
		node.Id = id
	}

	// Parse properties
	if val, ok := nodeData["technique_id"]; ok {
		if s, ok := val.(string); ok {
			node.TechniqueId = s
		}
	}
	if val, ok := nodeData["name"]; ok {
		if s, ok := val.(string); ok {
			node.Name = s
		}
	}
	if val, ok := nodeData["taxonomy"]; ok {
		if s, ok := val.(string); ok {
			node.Taxonomy = &s
		}
	}
	if val, ok := nodeData["tactic"]; ok {
		if s, ok := val.(string); ok {
			node.Tactic = &s
		}
	}
	if val, ok := nodeData["description"]; ok {
		if s, ok := val.(string); ok {
			node.Description = &s
		}
	}
	if val, ok := nodeData["url"]; ok {
		if s, ok := val.(string); ok {
			node.Url = &s
		}
	}

	return node, nil
}

