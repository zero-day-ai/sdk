// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: taxonomy/core.yaml
// Taxonomy Version: 3.0.0
// Generated at: 2026-01-23T17:09:14Z

package domain

import (
	"fmt"

	"github.com/zero-day-ai/sdk/api/gen/taxonomypb"
	"github.com/zero-day-ai/sdk/graphrag/validation"
)

// ==================== INTERFACES ====================

// GraphNode is implemented by all domain types.
type GraphNode interface {
	// NodeType returns the taxonomy node type string.
	NodeType() string

	// Properties returns all properties as a map.
	Properties() map[string]any

	// IdentifyingProperties returns the natural key properties.
	IdentifyingProperties() map[string]any

	// ParentRef returns the parent reference, or nil for root nodes.
	ParentRef() *NodeRef

	// Validate runs CEL validation rules. Returns nil for custom types.
	Validate() error

	// ToProto converts to the generic GraphNode proto.
	ToProto() *taxonomypb.GraphNode

	// ID returns the node ID (may be empty until stored).
	ID() string

	// SetID sets the node ID (called by harness after storage).
	SetID(id string)
}

// NodeRef references a parent node.
type NodeRef struct {
	NodeType     string
	Properties   map[string]any
	Relationship string
}

// ==================== HELPER FUNCTIONS ====================

func propsToValueMap(props map[string]any) map[string]*taxonomypb.Value {
	result := make(map[string]*taxonomypb.Value, len(props))
	for k, v := range props {
		result[k] = anyToValue(v)
	}
	return result
}

func anyToValue(v any) *taxonomypb.Value {
	if v == nil {
		return nil
	}
	switch val := v.(type) {
	case string:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_StringValue{StringValue: val}}
	case int:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_IntValue{IntValue: int64(val)}}
	case int32:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_IntValue{IntValue: int64(val)}}
	case int64:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_IntValue{IntValue: val}}
	case float64:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_DoubleValue{DoubleValue: val}}
	case float32:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_DoubleValue{DoubleValue: float64(val)}}
	case bool:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_BoolValue{BoolValue: val}}
	case []byte:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_BytesValue{BytesValue: val}}
	default:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_StringValue{StringValue: fmt.Sprintf("%v", val)}}
	}
}

// ==================== GENERATED DOMAIN TYPES ====================

// ==================== MISSION ====================

// Mission represents: Top-level security assessment mission
type Mission struct {
	proto  *taxonomypb.Mission
	parent *NodeRef
}

// NewMission creates a new Mission.
func NewMission(name string, target string) *Mission {
	return &Mission{
		proto: &taxonomypb.Mission{
			Name: name,
			Target: target,
		},
	}
}

// NodeType implements GraphNode.
func (n *Mission) NodeType() string { return "mission" }

// Properties implements GraphNode.
func (n *Mission) Properties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	props["target"] = n.proto.Target
	if n.proto.Status != nil {
		props["status"] = *n.proto.Status
	}
	if n.proto.Description != nil {
		props["description"] = *n.proto.Description
	}
	if n.proto.StartedAt != nil {
		props["started_at"] = *n.proto.StartedAt
	}
	if n.proto.CompletedAt != nil {
		props["completed_at"] = *n.proto.CompletedAt
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Mission) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	props["target"] = n.proto.Target
	return props
}

// ParentRef implements GraphNode.
func (n *Mission) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Mission) Validate() error {
	return validation.ValidateMission(n.proto)
}

// ToProto implements GraphNode.
func (n *Mission) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "mission",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Mission) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Mission) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// Name returns the name value.
func (n *Mission) Name() string {
	return n.proto.Name
}

// SetName sets the name value.
func (n *Mission) SetName(v string) *Mission {
	n.proto.Name = v
	return n
}

// Target returns the target value.
func (n *Mission) Target() string {
	return n.proto.Target
}

// SetTarget sets the target value.
func (n *Mission) SetTarget(v string) *Mission {
	n.proto.Target = v
	return n
}

// Status returns the status value.
func (n *Mission) Status() string {
	if n.proto.Status != nil {
		return *n.proto.Status
	}
	var zero string
	return zero
}

// SetStatus sets the status value.
func (n *Mission) SetStatus(v string) *Mission {
	n.proto.Status = &v
	return n
}

// Description returns the description value.
func (n *Mission) Description() string {
	if n.proto.Description != nil {
		return *n.proto.Description
	}
	var zero string
	return zero
}

// SetDescription sets the description value.
func (n *Mission) SetDescription(v string) *Mission {
	n.proto.Description = &v
	return n
}

// StartedAt returns the started_at value.
func (n *Mission) StartedAt() int64 {
	if n.proto.StartedAt != nil {
		return *n.proto.StartedAt
	}
	var zero int64
	return zero
}

// SetStartedAt sets the started_at value.
func (n *Mission) SetStartedAt(v int64) *Mission {
	n.proto.StartedAt = &v
	return n
}

// CompletedAt returns the completed_at value.
func (n *Mission) CompletedAt() int64 {
	if n.proto.CompletedAt != nil {
		return *n.proto.CompletedAt
	}
	var zero int64
	return zero
}

// SetCompletedAt sets the completed_at value.
func (n *Mission) SetCompletedAt(v int64) *Mission {
	n.proto.CompletedAt = &v
	return n
}


// ==================== MISSION_RUN ====================

// MissionRun represents: Single execution of a mission pipeline
type MissionRun struct {
	proto  *taxonomypb.MissionRun
	parent *NodeRef
}

// NewMissionRun creates a new MissionRun.
func NewMissionRun(run_number int32) *MissionRun {
	return &MissionRun{
		proto: &taxonomypb.MissionRun{
			RunNumber: run_number,
		},
	}
}

// NodeType implements GraphNode.
func (n *MissionRun) NodeType() string { return "mission_run" }

// Properties implements GraphNode.
func (n *MissionRun) Properties() map[string]any {
	props := make(map[string]any)
	props["run_number"] = n.proto.RunNumber
	if n.proto.Status != nil {
		props["status"] = *n.proto.Status
	}
	if n.proto.StartedAt != nil {
		props["started_at"] = *n.proto.StartedAt
	}
	if n.proto.CompletedAt != nil {
		props["completed_at"] = *n.proto.CompletedAt
	}
	if n.proto.ParentMissionId != "" {
		props["parent_mission_id"] = n.proto.ParentMissionId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *MissionRun) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["run_number"] = n.proto.RunNumber
	return props
}

// ParentRef implements GraphNode.
func (n *MissionRun) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentMissionId != "" {
		return &NodeRef{
			NodeType:     "mission",
			Properties:   map[string]any{"id": n.proto.ParentMissionId},
			Relationship: "HAS_RUN",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *MissionRun) Validate() error {
	if n.parent == nil && n.proto.ParentMissionId == "" {
		return fmt.Errorf("mission_run requires a parent of type mission (use BelongsTo)")
	}
	return validation.ValidateMissionRun(n.proto)
}

// ToProto implements GraphNode.
func (n *MissionRun) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "mission_run",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *MissionRun) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *MissionRun) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent mission.
func (n *MissionRun) BelongsTo(parent *Mission) *MissionRun {
	n.parent = &NodeRef{
		NodeType:     "mission",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "HAS_RUN",
	}
	n.proto.ParentMissionId = parent.ID()
	return n
}

// --- Typed Accessors ---

// RunNumber returns the run_number value.
func (n *MissionRun) RunNumber() int32 {
	return n.proto.RunNumber
}

// SetRunNumber sets the run_number value.
func (n *MissionRun) SetRunNumber(v int32) *MissionRun {
	n.proto.RunNumber = v
	return n
}

// Status returns the status value.
func (n *MissionRun) Status() string {
	if n.proto.Status != nil {
		return *n.proto.Status
	}
	var zero string
	return zero
}

// SetStatus sets the status value.
func (n *MissionRun) SetStatus(v string) *MissionRun {
	n.proto.Status = &v
	return n
}

// StartedAt returns the started_at value.
func (n *MissionRun) StartedAt() int64 {
	if n.proto.StartedAt != nil {
		return *n.proto.StartedAt
	}
	var zero int64
	return zero
}

// SetStartedAt sets the started_at value.
func (n *MissionRun) SetStartedAt(v int64) *MissionRun {
	n.proto.StartedAt = &v
	return n
}

// CompletedAt returns the completed_at value.
func (n *MissionRun) CompletedAt() int64 {
	if n.proto.CompletedAt != nil {
		return *n.proto.CompletedAt
	}
	var zero int64
	return zero
}

// SetCompletedAt sets the completed_at value.
func (n *MissionRun) SetCompletedAt(v int64) *MissionRun {
	n.proto.CompletedAt = &v
	return n
}


// ==================== AGENT_RUN ====================

// AgentRun represents: Single execution of an agent within a mission
type AgentRun struct {
	proto  *taxonomypb.AgentRun
	parent *NodeRef
}

// NewAgentRun creates a new AgentRun.
func NewAgentRun(agent_name string) *AgentRun {
	return &AgentRun{
		proto: &taxonomypb.AgentRun{
			AgentName: agent_name,
		},
	}
}

// NodeType implements GraphNode.
func (n *AgentRun) NodeType() string { return "agent_run" }

// Properties implements GraphNode.
func (n *AgentRun) Properties() map[string]any {
	props := make(map[string]any)
	props["agent_name"] = n.proto.AgentName
	if n.proto.Status != nil {
		props["status"] = *n.proto.Status
	}
	if n.proto.StartedAt != nil {
		props["started_at"] = *n.proto.StartedAt
	}
	if n.proto.CompletedAt != nil {
		props["completed_at"] = *n.proto.CompletedAt
	}
	if n.proto.ErrorMessage != nil {
		props["error_message"] = *n.proto.ErrorMessage
	}
	if n.proto.ParentMissionRunId != "" {
		props["parent_mission_run_id"] = n.proto.ParentMissionRunId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *AgentRun) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["agent_name"] = n.proto.AgentName
	return props
}

// ParentRef implements GraphNode.
func (n *AgentRun) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentMissionRunId != "" {
		return &NodeRef{
			NodeType:     "mission_run",
			Properties:   map[string]any{"id": n.proto.ParentMissionRunId},
			Relationship: "CONTAINS_AGENT_RUN",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *AgentRun) Validate() error {
	if n.parent == nil && n.proto.ParentMissionRunId == "" {
		return fmt.Errorf("agent_run requires a parent of type mission_run (use BelongsTo)")
	}
	return validation.ValidateAgentRun(n.proto)
}

// ToProto implements GraphNode.
func (n *AgentRun) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "agent_run",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *AgentRun) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *AgentRun) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent mission_run.
func (n *AgentRun) BelongsTo(parent *MissionRun) *AgentRun {
	n.parent = &NodeRef{
		NodeType:     "mission_run",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "CONTAINS_AGENT_RUN",
	}
	n.proto.ParentMissionRunId = parent.ID()
	return n
}

// --- Typed Accessors ---

// AgentName returns the agent_name value.
func (n *AgentRun) AgentName() string {
	return n.proto.AgentName
}

// SetAgentName sets the agent_name value.
func (n *AgentRun) SetAgentName(v string) *AgentRun {
	n.proto.AgentName = v
	return n
}

// Status returns the status value.
func (n *AgentRun) Status() string {
	if n.proto.Status != nil {
		return *n.proto.Status
	}
	var zero string
	return zero
}

// SetStatus sets the status value.
func (n *AgentRun) SetStatus(v string) *AgentRun {
	n.proto.Status = &v
	return n
}

// StartedAt returns the started_at value.
func (n *AgentRun) StartedAt() int64 {
	if n.proto.StartedAt != nil {
		return *n.proto.StartedAt
	}
	var zero int64
	return zero
}

// SetStartedAt sets the started_at value.
func (n *AgentRun) SetStartedAt(v int64) *AgentRun {
	n.proto.StartedAt = &v
	return n
}

// CompletedAt returns the completed_at value.
func (n *AgentRun) CompletedAt() int64 {
	if n.proto.CompletedAt != nil {
		return *n.proto.CompletedAt
	}
	var zero int64
	return zero
}

// SetCompletedAt sets the completed_at value.
func (n *AgentRun) SetCompletedAt(v int64) *AgentRun {
	n.proto.CompletedAt = &v
	return n
}

// ErrorMessage returns the error_message value.
func (n *AgentRun) ErrorMessage() string {
	if n.proto.ErrorMessage != nil {
		return *n.proto.ErrorMessage
	}
	var zero string
	return zero
}

// SetErrorMessage sets the error_message value.
func (n *AgentRun) SetErrorMessage(v string) *AgentRun {
	n.proto.ErrorMessage = &v
	return n
}


// ==================== TOOL_EXECUTION ====================

// ToolExecution represents: Execution of a security tool
type ToolExecution struct {
	proto  *taxonomypb.ToolExecution
	parent *NodeRef
}

// NewToolExecution creates a new ToolExecution.
func NewToolExecution(tool_name string) *ToolExecution {
	return &ToolExecution{
		proto: &taxonomypb.ToolExecution{
			ToolName: tool_name,
		},
	}
}

// NodeType implements GraphNode.
func (n *ToolExecution) NodeType() string { return "tool_execution" }

// Properties implements GraphNode.
func (n *ToolExecution) Properties() map[string]any {
	props := make(map[string]any)
	props["tool_name"] = n.proto.ToolName
	if n.proto.Command != nil {
		props["command"] = *n.proto.Command
	}
	if n.proto.ExitCode != nil {
		props["exit_code"] = *n.proto.ExitCode
	}
	if n.proto.StartedAt != nil {
		props["started_at"] = *n.proto.StartedAt
	}
	if n.proto.CompletedAt != nil {
		props["completed_at"] = *n.proto.CompletedAt
	}
	if n.proto.Stdout != nil {
		props["stdout"] = *n.proto.Stdout
	}
	if n.proto.Stderr != nil {
		props["stderr"] = *n.proto.Stderr
	}
	if n.proto.ParentAgentRunId != "" {
		props["parent_agent_run_id"] = n.proto.ParentAgentRunId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *ToolExecution) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["tool_name"] = n.proto.ToolName
	if n.proto.StartedAt != nil {
		props["started_at"] = *n.proto.StartedAt
	}
	return props
}

// ParentRef implements GraphNode.
func (n *ToolExecution) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentAgentRunId != "" {
		return &NodeRef{
			NodeType:     "agent_run",
			Properties:   map[string]any{"id": n.proto.ParentAgentRunId},
			Relationship: "EXECUTED_TOOL",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *ToolExecution) Validate() error {
	if n.parent == nil && n.proto.ParentAgentRunId == "" {
		return fmt.Errorf("tool_execution requires a parent of type agent_run (use BelongsTo)")
	}
	return validation.ValidateToolExecution(n.proto)
}

// ToProto implements GraphNode.
func (n *ToolExecution) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "tool_execution",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *ToolExecution) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *ToolExecution) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent agent_run.
func (n *ToolExecution) BelongsTo(parent *AgentRun) *ToolExecution {
	n.parent = &NodeRef{
		NodeType:     "agent_run",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "EXECUTED_TOOL",
	}
	n.proto.ParentAgentRunId = parent.ID()
	return n
}

// --- Typed Accessors ---

// ToolName returns the tool_name value.
func (n *ToolExecution) ToolName() string {
	return n.proto.ToolName
}

// SetToolName sets the tool_name value.
func (n *ToolExecution) SetToolName(v string) *ToolExecution {
	n.proto.ToolName = v
	return n
}

// Command returns the command value.
func (n *ToolExecution) Command() string {
	if n.proto.Command != nil {
		return *n.proto.Command
	}
	var zero string
	return zero
}

// SetCommand sets the command value.
func (n *ToolExecution) SetCommand(v string) *ToolExecution {
	n.proto.Command = &v
	return n
}

// ExitCode returns the exit_code value.
func (n *ToolExecution) ExitCode() int32 {
	if n.proto.ExitCode != nil {
		return *n.proto.ExitCode
	}
	var zero int32
	return zero
}

// SetExitCode sets the exit_code value.
func (n *ToolExecution) SetExitCode(v int32) *ToolExecution {
	n.proto.ExitCode = &v
	return n
}

// StartedAt returns the started_at value.
func (n *ToolExecution) StartedAt() int64 {
	if n.proto.StartedAt != nil {
		return *n.proto.StartedAt
	}
	var zero int64
	return zero
}

// SetStartedAt sets the started_at value.
func (n *ToolExecution) SetStartedAt(v int64) *ToolExecution {
	n.proto.StartedAt = &v
	return n
}

// CompletedAt returns the completed_at value.
func (n *ToolExecution) CompletedAt() int64 {
	if n.proto.CompletedAt != nil {
		return *n.proto.CompletedAt
	}
	var zero int64
	return zero
}

// SetCompletedAt sets the completed_at value.
func (n *ToolExecution) SetCompletedAt(v int64) *ToolExecution {
	n.proto.CompletedAt = &v
	return n
}

// Stdout returns the stdout value.
func (n *ToolExecution) Stdout() string {
	if n.proto.Stdout != nil {
		return *n.proto.Stdout
	}
	var zero string
	return zero
}

// SetStdout sets the stdout value.
func (n *ToolExecution) SetStdout(v string) *ToolExecution {
	n.proto.Stdout = &v
	return n
}

// Stderr returns the stderr value.
func (n *ToolExecution) Stderr() string {
	if n.proto.Stderr != nil {
		return *n.proto.Stderr
	}
	var zero string
	return zero
}

// SetStderr sets the stderr value.
func (n *ToolExecution) SetStderr(v string) *ToolExecution {
	n.proto.Stderr = &v
	return n
}


// ==================== LLM_CALL ====================

// LlmCall represents: Call to a large language model
type LlmCall struct {
	proto  *taxonomypb.LlmCall
	parent *NodeRef
}

// NewLlmCall creates a new LlmCall.
func NewLlmCall(model string) *LlmCall {
	return &LlmCall{
		proto: &taxonomypb.LlmCall{
			Model: model,
		},
	}
}

// NodeType implements GraphNode.
func (n *LlmCall) NodeType() string { return "llm_call" }

// Properties implements GraphNode.
func (n *LlmCall) Properties() map[string]any {
	props := make(map[string]any)
	props["model"] = n.proto.Model
	if n.proto.Provider != nil {
		props["provider"] = *n.proto.Provider
	}
	if n.proto.SlotName != nil {
		props["slot_name"] = *n.proto.SlotName
	}
	if n.proto.PromptTokens != nil {
		props["prompt_tokens"] = *n.proto.PromptTokens
	}
	if n.proto.CompletionTokens != nil {
		props["completion_tokens"] = *n.proto.CompletionTokens
	}
	if n.proto.TotalTokens != nil {
		props["total_tokens"] = *n.proto.TotalTokens
	}
	if n.proto.LatencyMs != nil {
		props["latency_ms"] = *n.proto.LatencyMs
	}
	if n.proto.StartedAt != nil {
		props["started_at"] = *n.proto.StartedAt
	}
	if n.proto.ParentAgentRunId != "" {
		props["parent_agent_run_id"] = n.proto.ParentAgentRunId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *LlmCall) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	return props
}

// ParentRef implements GraphNode.
func (n *LlmCall) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentAgentRunId != "" {
		return &NodeRef{
			NodeType:     "agent_run",
			Properties:   map[string]any{"id": n.proto.ParentAgentRunId},
			Relationship: "MADE_CALL",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *LlmCall) Validate() error {
	if n.parent == nil && n.proto.ParentAgentRunId == "" {
		return fmt.Errorf("llm_call requires a parent of type agent_run (use BelongsTo)")
	}
	return validation.ValidateLlmCall(n.proto)
}

// ToProto implements GraphNode.
func (n *LlmCall) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "llm_call",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *LlmCall) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *LlmCall) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent agent_run.
func (n *LlmCall) BelongsTo(parent *AgentRun) *LlmCall {
	n.parent = &NodeRef{
		NodeType:     "agent_run",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "MADE_CALL",
	}
	n.proto.ParentAgentRunId = parent.ID()
	return n
}

// --- Typed Accessors ---

// Model returns the model value.
func (n *LlmCall) Model() string {
	return n.proto.Model
}

// SetModel sets the model value.
func (n *LlmCall) SetModel(v string) *LlmCall {
	n.proto.Model = v
	return n
}

// Provider returns the provider value.
func (n *LlmCall) Provider() string {
	if n.proto.Provider != nil {
		return *n.proto.Provider
	}
	var zero string
	return zero
}

// SetProvider sets the provider value.
func (n *LlmCall) SetProvider(v string) *LlmCall {
	n.proto.Provider = &v
	return n
}

// SlotName returns the slot_name value.
func (n *LlmCall) SlotName() string {
	if n.proto.SlotName != nil {
		return *n.proto.SlotName
	}
	var zero string
	return zero
}

// SetSlotName sets the slot_name value.
func (n *LlmCall) SetSlotName(v string) *LlmCall {
	n.proto.SlotName = &v
	return n
}

// PromptTokens returns the prompt_tokens value.
func (n *LlmCall) PromptTokens() int32 {
	if n.proto.PromptTokens != nil {
		return *n.proto.PromptTokens
	}
	var zero int32
	return zero
}

// SetPromptTokens sets the prompt_tokens value.
func (n *LlmCall) SetPromptTokens(v int32) *LlmCall {
	n.proto.PromptTokens = &v
	return n
}

// CompletionTokens returns the completion_tokens value.
func (n *LlmCall) CompletionTokens() int32 {
	if n.proto.CompletionTokens != nil {
		return *n.proto.CompletionTokens
	}
	var zero int32
	return zero
}

// SetCompletionTokens sets the completion_tokens value.
func (n *LlmCall) SetCompletionTokens(v int32) *LlmCall {
	n.proto.CompletionTokens = &v
	return n
}

// TotalTokens returns the total_tokens value.
func (n *LlmCall) TotalTokens() int32 {
	if n.proto.TotalTokens != nil {
		return *n.proto.TotalTokens
	}
	var zero int32
	return zero
}

// SetTotalTokens sets the total_tokens value.
func (n *LlmCall) SetTotalTokens(v int32) *LlmCall {
	n.proto.TotalTokens = &v
	return n
}

// LatencyMs returns the latency_ms value.
func (n *LlmCall) LatencyMs() int64 {
	if n.proto.LatencyMs != nil {
		return *n.proto.LatencyMs
	}
	var zero int64
	return zero
}

// SetLatencyMs sets the latency_ms value.
func (n *LlmCall) SetLatencyMs(v int64) *LlmCall {
	n.proto.LatencyMs = &v
	return n
}

// StartedAt returns the started_at value.
func (n *LlmCall) StartedAt() int64 {
	if n.proto.StartedAt != nil {
		return *n.proto.StartedAt
	}
	var zero int64
	return zero
}

// SetStartedAt sets the started_at value.
func (n *LlmCall) SetStartedAt(v int64) *LlmCall {
	n.proto.StartedAt = &v
	return n
}


// ==================== DOMAIN ====================

// Domain represents: Root domain entity (e.g., example.com)
type Domain struct {
	proto  *taxonomypb.Domain
	parent *NodeRef
}

// NewDomain creates a new Domain.
func NewDomain(name string) *Domain {
	return &Domain{
		proto: &taxonomypb.Domain{
			Name: name,
		},
	}
}

// NodeType implements GraphNode.
func (n *Domain) NodeType() string { return "domain" }

// Properties implements GraphNode.
func (n *Domain) Properties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	if n.proto.Registrar != nil {
		props["registrar"] = *n.proto.Registrar
	}
	if n.proto.CreatedDate != nil {
		props["created_date"] = *n.proto.CreatedDate
	}
	if n.proto.ExpiryDate != nil {
		props["expiry_date"] = *n.proto.ExpiryDate
	}
	if n.proto.Nameservers != nil {
		props["nameservers"] = *n.proto.Nameservers
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Domain) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	return props
}

// ParentRef implements GraphNode.
func (n *Domain) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Domain) Validate() error {
	return validation.ValidateDomain(n.proto)
}

// ToProto implements GraphNode.
func (n *Domain) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "domain",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Domain) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Domain) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// Name returns the name value.
func (n *Domain) Name() string {
	return n.proto.Name
}

// SetName sets the name value.
func (n *Domain) SetName(v string) *Domain {
	n.proto.Name = v
	return n
}

// Registrar returns the registrar value.
func (n *Domain) Registrar() string {
	if n.proto.Registrar != nil {
		return *n.proto.Registrar
	}
	var zero string
	return zero
}

// SetRegistrar sets the registrar value.
func (n *Domain) SetRegistrar(v string) *Domain {
	n.proto.Registrar = &v
	return n
}

// CreatedDate returns the created_date value.
func (n *Domain) CreatedDate() int64 {
	if n.proto.CreatedDate != nil {
		return *n.proto.CreatedDate
	}
	var zero int64
	return zero
}

// SetCreatedDate sets the created_date value.
func (n *Domain) SetCreatedDate(v int64) *Domain {
	n.proto.CreatedDate = &v
	return n
}

// ExpiryDate returns the expiry_date value.
func (n *Domain) ExpiryDate() int64 {
	if n.proto.ExpiryDate != nil {
		return *n.proto.ExpiryDate
	}
	var zero int64
	return zero
}

// SetExpiryDate sets the expiry_date value.
func (n *Domain) SetExpiryDate(v int64) *Domain {
	n.proto.ExpiryDate = &v
	return n
}

// Nameservers returns the nameservers value.
func (n *Domain) Nameservers() string {
	if n.proto.Nameservers != nil {
		return *n.proto.Nameservers
	}
	var zero string
	return zero
}

// SetNameservers sets the nameservers value.
func (n *Domain) SetNameservers(v string) *Domain {
	n.proto.Nameservers = &v
	return n
}


// ==================== SUBDOMAIN ====================

// Subdomain represents: Subdomain under a root domain
type Subdomain struct {
	proto  *taxonomypb.Subdomain
	parent *NodeRef
}

// NewSubdomain creates a new Subdomain.
func NewSubdomain(name string) *Subdomain {
	return &Subdomain{
		proto: &taxonomypb.Subdomain{
			Name: name,
		},
	}
}

// NodeType implements GraphNode.
func (n *Subdomain) NodeType() string { return "subdomain" }

// Properties implements GraphNode.
func (n *Subdomain) Properties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	if n.proto.FullName != nil {
		props["full_name"] = *n.proto.FullName
	}
	if n.proto.ParentDomainId != "" {
		props["parent_domain_id"] = n.proto.ParentDomainId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Subdomain) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	return props
}

// ParentRef implements GraphNode.
func (n *Subdomain) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentDomainId != "" {
		return &NodeRef{
			NodeType:     "domain",
			Properties:   map[string]any{"id": n.proto.ParentDomainId},
			Relationship: "HAS_SUBDOMAIN",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *Subdomain) Validate() error {
	if n.parent == nil && n.proto.ParentDomainId == "" {
		return fmt.Errorf("subdomain requires a parent of type domain (use BelongsTo)")
	}
	return validation.ValidateSubdomain(n.proto)
}

// ToProto implements GraphNode.
func (n *Subdomain) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "subdomain",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Subdomain) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Subdomain) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent domain.
func (n *Subdomain) BelongsTo(parent *Domain) *Subdomain {
	n.parent = &NodeRef{
		NodeType:     "domain",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "HAS_SUBDOMAIN",
	}
	n.proto.ParentDomainId = parent.ID()
	return n
}

// --- Typed Accessors ---

// Name returns the name value.
func (n *Subdomain) Name() string {
	return n.proto.Name
}

// SetName sets the name value.
func (n *Subdomain) SetName(v string) *Subdomain {
	n.proto.Name = v
	return n
}

// FullName returns the full_name value.
func (n *Subdomain) FullName() string {
	if n.proto.FullName != nil {
		return *n.proto.FullName
	}
	var zero string
	return zero
}

// SetFullName sets the full_name value.
func (n *Subdomain) SetFullName(v string) *Subdomain {
	n.proto.FullName = &v
	return n
}


// ==================== HOST ====================

// Host represents: IP address or hostname
type Host struct {
	proto  *taxonomypb.Host
	parent *NodeRef
}

// NewHost creates a new Host.
func NewHost() *Host {
	return &Host{
		proto: &taxonomypb.Host{},
	}
}

// NodeType implements GraphNode.
func (n *Host) NodeType() string { return "host" }

// Properties implements GraphNode.
func (n *Host) Properties() map[string]any {
	props := make(map[string]any)
	if n.proto.Ip != nil {
		props["ip"] = *n.proto.Ip
	}
	if n.proto.Hostname != nil {
		props["hostname"] = *n.proto.Hostname
	}
	if n.proto.Os != nil {
		props["os"] = *n.proto.Os
	}
	if n.proto.OsVersion != nil {
		props["os_version"] = *n.proto.OsVersion
	}
	if n.proto.MacAddress != nil {
		props["mac_address"] = *n.proto.MacAddress
	}
	if n.proto.State != nil {
		props["state"] = *n.proto.State
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Host) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	if n.proto.Ip != nil {
		props["ip"] = *n.proto.Ip
	}
	return props
}

// ParentRef implements GraphNode.
func (n *Host) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Host) Validate() error {
	return validation.ValidateHost(n.proto)
}

// ToProto implements GraphNode.
func (n *Host) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "host",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Host) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Host) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// Ip returns the ip value.
func (n *Host) Ip() string {
	if n.proto.Ip != nil {
		return *n.proto.Ip
	}
	var zero string
	return zero
}

// SetIp sets the ip value.
func (n *Host) SetIp(v string) *Host {
	n.proto.Ip = &v
	return n
}

// Hostname returns the hostname value.
func (n *Host) Hostname() string {
	if n.proto.Hostname != nil {
		return *n.proto.Hostname
	}
	var zero string
	return zero
}

// SetHostname sets the hostname value.
func (n *Host) SetHostname(v string) *Host {
	n.proto.Hostname = &v
	return n
}

// Os returns the os value.
func (n *Host) Os() string {
	if n.proto.Os != nil {
		return *n.proto.Os
	}
	var zero string
	return zero
}

// SetOs sets the os value.
func (n *Host) SetOs(v string) *Host {
	n.proto.Os = &v
	return n
}

// OsVersion returns the os_version value.
func (n *Host) OsVersion() string {
	if n.proto.OsVersion != nil {
		return *n.proto.OsVersion
	}
	var zero string
	return zero
}

// SetOsVersion sets the os_version value.
func (n *Host) SetOsVersion(v string) *Host {
	n.proto.OsVersion = &v
	return n
}

// MacAddress returns the mac_address value.
func (n *Host) MacAddress() string {
	if n.proto.MacAddress != nil {
		return *n.proto.MacAddress
	}
	var zero string
	return zero
}

// SetMacAddress sets the mac_address value.
func (n *Host) SetMacAddress(v string) *Host {
	n.proto.MacAddress = &v
	return n
}

// State returns the state value.
func (n *Host) State() string {
	if n.proto.State != nil {
		return *n.proto.State
	}
	var zero string
	return zero
}

// SetState sets the state value.
func (n *Host) SetState(v string) *Host {
	n.proto.State = &v
	return n
}


// ==================== PORT ====================

// Port represents: Network port on a host
type Port struct {
	proto  *taxonomypb.Port
	parent *NodeRef
}

// NewPort creates a new Port.
func NewPort(number int32, protocol string) *Port {
	return &Port{
		proto: &taxonomypb.Port{
			Number: number,
			Protocol: protocol,
		},
	}
}

// NodeType implements GraphNode.
func (n *Port) NodeType() string { return "port" }

// Properties implements GraphNode.
func (n *Port) Properties() map[string]any {
	props := make(map[string]any)
	props["number"] = n.proto.Number
	props["protocol"] = n.proto.Protocol
	if n.proto.State != nil {
		props["state"] = *n.proto.State
	}
	if n.proto.Reason != nil {
		props["reason"] = *n.proto.Reason
	}
	if n.proto.ParentHostId != "" {
		props["parent_host_id"] = n.proto.ParentHostId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Port) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["number"] = n.proto.Number
	props["protocol"] = n.proto.Protocol
	return props
}

// ParentRef implements GraphNode.
func (n *Port) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentHostId != "" {
		return &NodeRef{
			NodeType:     "host",
			Properties:   map[string]any{"id": n.proto.ParentHostId},
			Relationship: "HAS_PORT",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *Port) Validate() error {
	if n.parent == nil && n.proto.ParentHostId == "" {
		return fmt.Errorf("port requires a parent of type host (use BelongsTo)")
	}
	return validation.ValidatePort(n.proto)
}

// ToProto implements GraphNode.
func (n *Port) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "port",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Port) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Port) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent host.
func (n *Port) BelongsTo(parent *Host) *Port {
	n.parent = &NodeRef{
		NodeType:     "host",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "HAS_PORT",
	}
	n.proto.ParentHostId = parent.ID()
	return n
}

// --- Typed Accessors ---

// Number returns the number value.
func (n *Port) Number() int32 {
	return n.proto.Number
}

// SetNumber sets the number value.
func (n *Port) SetNumber(v int32) *Port {
	n.proto.Number = v
	return n
}

// Protocol returns the protocol value.
func (n *Port) Protocol() string {
	return n.proto.Protocol
}

// SetProtocol sets the protocol value.
func (n *Port) SetProtocol(v string) *Port {
	n.proto.Protocol = v
	return n
}

// State returns the state value.
func (n *Port) State() string {
	if n.proto.State != nil {
		return *n.proto.State
	}
	var zero string
	return zero
}

// SetState sets the state value.
func (n *Port) SetState(v string) *Port {
	n.proto.State = &v
	return n
}

// Reason returns the reason value.
func (n *Port) Reason() string {
	if n.proto.Reason != nil {
		return *n.proto.Reason
	}
	var zero string
	return zero
}

// SetReason sets the reason value.
func (n *Port) SetReason(v string) *Port {
	n.proto.Reason = &v
	return n
}


// ==================== SERVICE ====================

// Service represents: Service running on a port
type Service struct {
	proto  *taxonomypb.Service
	parent *NodeRef
}

// NewService creates a new Service.
func NewService(name string) *Service {
	return &Service{
		proto: &taxonomypb.Service{
			Name: name,
		},
	}
}

// NodeType implements GraphNode.
func (n *Service) NodeType() string { return "service" }

// Properties implements GraphNode.
func (n *Service) Properties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	if n.proto.Product != nil {
		props["product"] = *n.proto.Product
	}
	if n.proto.Version != nil {
		props["version"] = *n.proto.Version
	}
	if n.proto.ExtraInfo != nil {
		props["extra_info"] = *n.proto.ExtraInfo
	}
	if n.proto.Banner != nil {
		props["banner"] = *n.proto.Banner
	}
	if n.proto.Cpe != nil {
		props["cpe"] = *n.proto.Cpe
	}
	if n.proto.ParentPortId != "" {
		props["parent_port_id"] = n.proto.ParentPortId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Service) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	return props
}

// ParentRef implements GraphNode.
func (n *Service) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentPortId != "" {
		return &NodeRef{
			NodeType:     "port",
			Properties:   map[string]any{"id": n.proto.ParentPortId},
			Relationship: "RUNS_SERVICE",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *Service) Validate() error {
	if n.parent == nil && n.proto.ParentPortId == "" {
		return fmt.Errorf("service requires a parent of type port (use BelongsTo)")
	}
	return validation.ValidateService(n.proto)
}

// ToProto implements GraphNode.
func (n *Service) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "service",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Service) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Service) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent port.
func (n *Service) BelongsTo(parent *Port) *Service {
	n.parent = &NodeRef{
		NodeType:     "port",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "RUNS_SERVICE",
	}
	n.proto.ParentPortId = parent.ID()
	return n
}

// --- Typed Accessors ---

// Name returns the name value.
func (n *Service) Name() string {
	return n.proto.Name
}

// SetName sets the name value.
func (n *Service) SetName(v string) *Service {
	n.proto.Name = v
	return n
}

// Product returns the product value.
func (n *Service) Product() string {
	if n.proto.Product != nil {
		return *n.proto.Product
	}
	var zero string
	return zero
}

// SetProduct sets the product value.
func (n *Service) SetProduct(v string) *Service {
	n.proto.Product = &v
	return n
}

// Version returns the version value.
func (n *Service) Version() string {
	if n.proto.Version != nil {
		return *n.proto.Version
	}
	var zero string
	return zero
}

// SetVersion sets the version value.
func (n *Service) SetVersion(v string) *Service {
	n.proto.Version = &v
	return n
}

// ExtraInfo returns the extra_info value.
func (n *Service) ExtraInfo() string {
	if n.proto.ExtraInfo != nil {
		return *n.proto.ExtraInfo
	}
	var zero string
	return zero
}

// SetExtraInfo sets the extra_info value.
func (n *Service) SetExtraInfo(v string) *Service {
	n.proto.ExtraInfo = &v
	return n
}

// Banner returns the banner value.
func (n *Service) Banner() string {
	if n.proto.Banner != nil {
		return *n.proto.Banner
	}
	var zero string
	return zero
}

// SetBanner sets the banner value.
func (n *Service) SetBanner(v string) *Service {
	n.proto.Banner = &v
	return n
}

// Cpe returns the cpe value.
func (n *Service) Cpe() string {
	if n.proto.Cpe != nil {
		return *n.proto.Cpe
	}
	var zero string
	return zero
}

// SetCpe sets the cpe value.
func (n *Service) SetCpe(v string) *Service {
	n.proto.Cpe = &v
	return n
}


// ==================== ENDPOINT ====================

// Endpoint represents: Web endpoint or URL
type Endpoint struct {
	proto  *taxonomypb.Endpoint
	parent *NodeRef
}

// NewEndpoint creates a new Endpoint.
func NewEndpoint(url string) *Endpoint {
	return &Endpoint{
		proto: &taxonomypb.Endpoint{
			Url: url,
		},
	}
}

// NodeType implements GraphNode.
func (n *Endpoint) NodeType() string { return "endpoint" }

// Properties implements GraphNode.
func (n *Endpoint) Properties() map[string]any {
	props := make(map[string]any)
	props["url"] = n.proto.Url
	if n.proto.Method != nil {
		props["method"] = *n.proto.Method
	}
	if n.proto.StatusCode != nil {
		props["status_code"] = *n.proto.StatusCode
	}
	if n.proto.ContentType != nil {
		props["content_type"] = *n.proto.ContentType
	}
	if n.proto.ContentLength != nil {
		props["content_length"] = *n.proto.ContentLength
	}
	if n.proto.Title != nil {
		props["title"] = *n.proto.Title
	}
	if n.proto.ParentServiceId != "" {
		props["parent_service_id"] = n.proto.ParentServiceId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Endpoint) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["url"] = n.proto.Url
	if n.proto.Method != nil {
		props["method"] = *n.proto.Method
	}
	return props
}

// ParentRef implements GraphNode.
func (n *Endpoint) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentServiceId != "" {
		return &NodeRef{
			NodeType:     "service",
			Properties:   map[string]any{"id": n.proto.ParentServiceId},
			Relationship: "HAS_ENDPOINT",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *Endpoint) Validate() error {
	if n.parent == nil && n.proto.ParentServiceId == "" {
		return fmt.Errorf("endpoint requires a parent of type service (use BelongsTo)")
	}
	return validation.ValidateEndpoint(n.proto)
}

// ToProto implements GraphNode.
func (n *Endpoint) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "endpoint",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Endpoint) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Endpoint) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent service.
func (n *Endpoint) BelongsTo(parent *Service) *Endpoint {
	n.parent = &NodeRef{
		NodeType:     "service",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "HAS_ENDPOINT",
	}
	n.proto.ParentServiceId = parent.ID()
	return n
}

// --- Typed Accessors ---

// Url returns the url value.
func (n *Endpoint) Url() string {
	return n.proto.Url
}

// SetUrl sets the url value.
func (n *Endpoint) SetUrl(v string) *Endpoint {
	n.proto.Url = v
	return n
}

// Method returns the method value.
func (n *Endpoint) Method() string {
	if n.proto.Method != nil {
		return *n.proto.Method
	}
	var zero string
	return zero
}

// SetMethod sets the method value.
func (n *Endpoint) SetMethod(v string) *Endpoint {
	n.proto.Method = &v
	return n
}

// StatusCode returns the status_code value.
func (n *Endpoint) StatusCode() int32 {
	if n.proto.StatusCode != nil {
		return *n.proto.StatusCode
	}
	var zero int32
	return zero
}

// SetStatusCode sets the status_code value.
func (n *Endpoint) SetStatusCode(v int32) *Endpoint {
	n.proto.StatusCode = &v
	return n
}

// ContentType returns the content_type value.
func (n *Endpoint) ContentType() string {
	if n.proto.ContentType != nil {
		return *n.proto.ContentType
	}
	var zero string
	return zero
}

// SetContentType sets the content_type value.
func (n *Endpoint) SetContentType(v string) *Endpoint {
	n.proto.ContentType = &v
	return n
}

// ContentLength returns the content_length value.
func (n *Endpoint) ContentLength() int64 {
	if n.proto.ContentLength != nil {
		return *n.proto.ContentLength
	}
	var zero int64
	return zero
}

// SetContentLength sets the content_length value.
func (n *Endpoint) SetContentLength(v int64) *Endpoint {
	n.proto.ContentLength = &v
	return n
}

// Title returns the title value.
func (n *Endpoint) Title() string {
	if n.proto.Title != nil {
		return *n.proto.Title
	}
	var zero string
	return zero
}

// SetTitle sets the title value.
func (n *Endpoint) SetTitle(v string) *Endpoint {
	n.proto.Title = &v
	return n
}


// ==================== TECHNOLOGY ====================

// Technology represents: Technology/framework detected
type Technology struct {
	proto  *taxonomypb.Technology
	parent *NodeRef
}

// NewTechnology creates a new Technology.
func NewTechnology(name string) *Technology {
	return &Technology{
		proto: &taxonomypb.Technology{
			Name: name,
		},
	}
}

// NodeType implements GraphNode.
func (n *Technology) NodeType() string { return "technology" }

// Properties implements GraphNode.
func (n *Technology) Properties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	if n.proto.Version != nil {
		props["version"] = *n.proto.Version
	}
	if n.proto.Category != nil {
		props["category"] = *n.proto.Category
	}
	if n.proto.Confidence != nil {
		props["confidence"] = *n.proto.Confidence
	}
	if n.proto.Cpe != nil {
		props["cpe"] = *n.proto.Cpe
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Technology) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["name"] = n.proto.Name
	if n.proto.Version != nil {
		props["version"] = *n.proto.Version
	}
	return props
}

// ParentRef implements GraphNode.
func (n *Technology) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Technology) Validate() error {
	return validation.ValidateTechnology(n.proto)
}

// ToProto implements GraphNode.
func (n *Technology) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "technology",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Technology) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Technology) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// Name returns the name value.
func (n *Technology) Name() string {
	return n.proto.Name
}

// SetName sets the name value.
func (n *Technology) SetName(v string) *Technology {
	n.proto.Name = v
	return n
}

// Version returns the version value.
func (n *Technology) Version() string {
	if n.proto.Version != nil {
		return *n.proto.Version
	}
	var zero string
	return zero
}

// SetVersion sets the version value.
func (n *Technology) SetVersion(v string) *Technology {
	n.proto.Version = &v
	return n
}

// Category returns the category value.
func (n *Technology) Category() string {
	if n.proto.Category != nil {
		return *n.proto.Category
	}
	var zero string
	return zero
}

// SetCategory sets the category value.
func (n *Technology) SetCategory(v string) *Technology {
	n.proto.Category = &v
	return n
}

// Confidence returns the confidence value.
func (n *Technology) Confidence() int32 {
	if n.proto.Confidence != nil {
		return *n.proto.Confidence
	}
	var zero int32
	return zero
}

// SetConfidence sets the confidence value.
func (n *Technology) SetConfidence(v int32) *Technology {
	n.proto.Confidence = &v
	return n
}

// Cpe returns the cpe value.
func (n *Technology) Cpe() string {
	if n.proto.Cpe != nil {
		return *n.proto.Cpe
	}
	var zero string
	return zero
}

// SetCpe sets the cpe value.
func (n *Technology) SetCpe(v string) *Technology {
	n.proto.Cpe = &v
	return n
}


// ==================== CERTIFICATE ====================

// Certificate represents: TLS/SSL certificate
type Certificate struct {
	proto  *taxonomypb.Certificate
	parent *NodeRef
}

// NewCertificate creates a new Certificate.
func NewCertificate() *Certificate {
	return &Certificate{
		proto: &taxonomypb.Certificate{},
	}
}

// NodeType implements GraphNode.
func (n *Certificate) NodeType() string { return "certificate" }

// Properties implements GraphNode.
func (n *Certificate) Properties() map[string]any {
	props := make(map[string]any)
	if n.proto.Subject != nil {
		props["subject"] = *n.proto.Subject
	}
	if n.proto.Issuer != nil {
		props["issuer"] = *n.proto.Issuer
	}
	if n.proto.SerialNumber != nil {
		props["serial_number"] = *n.proto.SerialNumber
	}
	if n.proto.NotBefore != nil {
		props["not_before"] = *n.proto.NotBefore
	}
	if n.proto.NotAfter != nil {
		props["not_after"] = *n.proto.NotAfter
	}
	if n.proto.FingerprintSha256 != nil {
		props["fingerprint_sha256"] = *n.proto.FingerprintSha256
	}
	if n.proto.San != nil {
		props["san"] = *n.proto.San
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Certificate) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	if n.proto.FingerprintSha256 != nil {
		props["fingerprint_sha256"] = *n.proto.FingerprintSha256
	}
	return props
}

// ParentRef implements GraphNode.
func (n *Certificate) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Certificate) Validate() error {
	return validation.ValidateCertificate(n.proto)
}

// ToProto implements GraphNode.
func (n *Certificate) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "certificate",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Certificate) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Certificate) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// Subject returns the subject value.
func (n *Certificate) Subject() string {
	if n.proto.Subject != nil {
		return *n.proto.Subject
	}
	var zero string
	return zero
}

// SetSubject sets the subject value.
func (n *Certificate) SetSubject(v string) *Certificate {
	n.proto.Subject = &v
	return n
}

// Issuer returns the issuer value.
func (n *Certificate) Issuer() string {
	if n.proto.Issuer != nil {
		return *n.proto.Issuer
	}
	var zero string
	return zero
}

// SetIssuer sets the issuer value.
func (n *Certificate) SetIssuer(v string) *Certificate {
	n.proto.Issuer = &v
	return n
}

// SerialNumber returns the serial_number value.
func (n *Certificate) SerialNumber() string {
	if n.proto.SerialNumber != nil {
		return *n.proto.SerialNumber
	}
	var zero string
	return zero
}

// SetSerialNumber sets the serial_number value.
func (n *Certificate) SetSerialNumber(v string) *Certificate {
	n.proto.SerialNumber = &v
	return n
}

// NotBefore returns the not_before value.
func (n *Certificate) NotBefore() int64 {
	if n.proto.NotBefore != nil {
		return *n.proto.NotBefore
	}
	var zero int64
	return zero
}

// SetNotBefore sets the not_before value.
func (n *Certificate) SetNotBefore(v int64) *Certificate {
	n.proto.NotBefore = &v
	return n
}

// NotAfter returns the not_after value.
func (n *Certificate) NotAfter() int64 {
	if n.proto.NotAfter != nil {
		return *n.proto.NotAfter
	}
	var zero int64
	return zero
}

// SetNotAfter sets the not_after value.
func (n *Certificate) SetNotAfter(v int64) *Certificate {
	n.proto.NotAfter = &v
	return n
}

// FingerprintSha256 returns the fingerprint_sha256 value.
func (n *Certificate) FingerprintSha256() string {
	if n.proto.FingerprintSha256 != nil {
		return *n.proto.FingerprintSha256
	}
	var zero string
	return zero
}

// SetFingerprintSha256 sets the fingerprint_sha256 value.
func (n *Certificate) SetFingerprintSha256(v string) *Certificate {
	n.proto.FingerprintSha256 = &v
	return n
}

// San returns the san value.
func (n *Certificate) San() string {
	if n.proto.San != nil {
		return *n.proto.San
	}
	var zero string
	return zero
}

// SetSan sets the san value.
func (n *Certificate) SetSan(v string) *Certificate {
	n.proto.San = &v
	return n
}


// ==================== FINDING ====================

// Finding represents: Security vulnerability or issue
type Finding struct {
	proto  *taxonomypb.Finding
	parent *NodeRef
}

// NewFinding creates a new Finding.
func NewFinding(title string, severity string) *Finding {
	return &Finding{
		proto: &taxonomypb.Finding{
			Title: title,
			Severity: severity,
		},
	}
}

// NodeType implements GraphNode.
func (n *Finding) NodeType() string { return "finding" }

// Properties implements GraphNode.
func (n *Finding) Properties() map[string]any {
	props := make(map[string]any)
	props["title"] = n.proto.Title
	if n.proto.Description != nil {
		props["description"] = *n.proto.Description
	}
	props["severity"] = n.proto.Severity
	if n.proto.Confidence != nil {
		props["confidence"] = *n.proto.Confidence
	}
	if n.proto.Category != nil {
		props["category"] = *n.proto.Category
	}
	if n.proto.Subcategory != nil {
		props["subcategory"] = *n.proto.Subcategory
	}
	if n.proto.Remediation != nil {
		props["remediation"] = *n.proto.Remediation
	}
	if n.proto.CvssScore != nil {
		props["cvss_score"] = *n.proto.CvssScore
	}
	if n.proto.CveIds != nil {
		props["cve_ids"] = *n.proto.CveIds
	}
	if n.proto.CweIds != nil {
		props["cwe_ids"] = *n.proto.CweIds
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Finding) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["title"] = n.proto.Title
	return props
}

// ParentRef implements GraphNode.
func (n *Finding) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Finding) Validate() error {
	return validation.ValidateFinding(n.proto)
}

// ToProto implements GraphNode.
func (n *Finding) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "finding",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Finding) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Finding) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// Title returns the title value.
func (n *Finding) Title() string {
	return n.proto.Title
}

// SetTitle sets the title value.
func (n *Finding) SetTitle(v string) *Finding {
	n.proto.Title = v
	return n
}

// Description returns the description value.
func (n *Finding) Description() string {
	if n.proto.Description != nil {
		return *n.proto.Description
	}
	var zero string
	return zero
}

// SetDescription sets the description value.
func (n *Finding) SetDescription(v string) *Finding {
	n.proto.Description = &v
	return n
}

// Severity returns the severity value.
func (n *Finding) Severity() string {
	return n.proto.Severity
}

// SetSeverity sets the severity value.
func (n *Finding) SetSeverity(v string) *Finding {
	n.proto.Severity = v
	return n
}

// Confidence returns the confidence value.
func (n *Finding) Confidence() float64 {
	if n.proto.Confidence != nil {
		return *n.proto.Confidence
	}
	var zero float64
	return zero
}

// SetConfidence sets the confidence value.
func (n *Finding) SetConfidence(v float64) *Finding {
	n.proto.Confidence = &v
	return n
}

// Category returns the category value.
func (n *Finding) Category() string {
	if n.proto.Category != nil {
		return *n.proto.Category
	}
	var zero string
	return zero
}

// SetCategory sets the category value.
func (n *Finding) SetCategory(v string) *Finding {
	n.proto.Category = &v
	return n
}

// Subcategory returns the subcategory value.
func (n *Finding) Subcategory() string {
	if n.proto.Subcategory != nil {
		return *n.proto.Subcategory
	}
	var zero string
	return zero
}

// SetSubcategory sets the subcategory value.
func (n *Finding) SetSubcategory(v string) *Finding {
	n.proto.Subcategory = &v
	return n
}

// Remediation returns the remediation value.
func (n *Finding) Remediation() string {
	if n.proto.Remediation != nil {
		return *n.proto.Remediation
	}
	var zero string
	return zero
}

// SetRemediation sets the remediation value.
func (n *Finding) SetRemediation(v string) *Finding {
	n.proto.Remediation = &v
	return n
}

// CvssScore returns the cvss_score value.
func (n *Finding) CvssScore() float64 {
	if n.proto.CvssScore != nil {
		return *n.proto.CvssScore
	}
	var zero float64
	return zero
}

// SetCvssScore sets the cvss_score value.
func (n *Finding) SetCvssScore(v float64) *Finding {
	n.proto.CvssScore = &v
	return n
}

// CveIds returns the cve_ids value.
func (n *Finding) CveIds() string {
	if n.proto.CveIds != nil {
		return *n.proto.CveIds
	}
	var zero string
	return zero
}

// SetCveIds sets the cve_ids value.
func (n *Finding) SetCveIds(v string) *Finding {
	n.proto.CveIds = &v
	return n
}

// CweIds returns the cwe_ids value.
func (n *Finding) CweIds() string {
	if n.proto.CweIds != nil {
		return *n.proto.CweIds
	}
	var zero string
	return zero
}

// SetCweIds sets the cwe_ids value.
func (n *Finding) SetCweIds(v string) *Finding {
	n.proto.CweIds = &v
	return n
}


// ==================== EVIDENCE ====================

// Evidence represents: Supporting evidence for a finding
type Evidence struct {
	proto  *taxonomypb.Evidence
	parent *NodeRef
}

// NewEvidence creates a new Evidence.
func NewEvidence(type_ string) *Evidence {
	return &Evidence{
		proto: &taxonomypb.Evidence{
			Type: type_,
		},
	}
}

// NodeType implements GraphNode.
func (n *Evidence) NodeType() string { return "evidence" }

// Properties implements GraphNode.
func (n *Evidence) Properties() map[string]any {
	props := make(map[string]any)
	props["type"] = n.proto.Type
	if n.proto.Content != nil {
		props["content"] = *n.proto.Content
	}
	if n.proto.ContentType != nil {
		props["content_type"] = *n.proto.ContentType
	}
	if n.proto.Url != nil {
		props["url"] = *n.proto.Url
	}
	if n.proto.ParentFindingId != "" {
		props["parent_finding_id"] = n.proto.ParentFindingId
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Evidence) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	return props
}

// ParentRef implements GraphNode.
func (n *Evidence) ParentRef() *NodeRef {
	if n.parent != nil {
		return n.parent
	}
	if n.proto.ParentFindingId != "" {
		return &NodeRef{
			NodeType:     "finding",
			Properties:   map[string]any{"id": n.proto.ParentFindingId},
			Relationship: "HAS_EVIDENCE",
		}
	}
	return nil
}

// Validate implements GraphNode.
func (n *Evidence) Validate() error {
	if n.parent == nil && n.proto.ParentFindingId == "" {
		return fmt.Errorf("evidence requires a parent of type finding (use BelongsTo)")
	}
	return validation.ValidateEvidence(n.proto)
}

// ToProto implements GraphNode.
func (n *Evidence) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "evidence",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Evidence) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Evidence) SetID(id string) { n.proto.Id = id }

// BelongsTo sets the parent finding.
func (n *Evidence) BelongsTo(parent *Finding) *Evidence {
	n.parent = &NodeRef{
		NodeType:     "finding",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "HAS_EVIDENCE",
	}
	n.proto.ParentFindingId = parent.ID()
	return n
}

// --- Typed Accessors ---

// Type returns the type value.
func (n *Evidence) Type() string {
	return n.proto.Type
}

// SetType sets the type value.
func (n *Evidence) SetType(v string) *Evidence {
	n.proto.Type = v
	return n
}

// Content returns the content value.
func (n *Evidence) Content() string {
	if n.proto.Content != nil {
		return *n.proto.Content
	}
	var zero string
	return zero
}

// SetContent sets the content value.
func (n *Evidence) SetContent(v string) *Evidence {
	n.proto.Content = &v
	return n
}

// ContentType returns the content_type value.
func (n *Evidence) ContentType() string {
	if n.proto.ContentType != nil {
		return *n.proto.ContentType
	}
	var zero string
	return zero
}

// SetContentType sets the content_type value.
func (n *Evidence) SetContentType(v string) *Evidence {
	n.proto.ContentType = &v
	return n
}

// Url returns the url value.
func (n *Evidence) Url() string {
	if n.proto.Url != nil {
		return *n.proto.Url
	}
	var zero string
	return zero
}

// SetUrl sets the url value.
func (n *Evidence) SetUrl(v string) *Evidence {
	n.proto.Url = &v
	return n
}


// ==================== TECHNIQUE ====================

// Technique represents: Attack technique (MITRE/Gibson)
type Technique struct {
	proto  *taxonomypb.Technique
	parent *NodeRef
}

// NewTechnique creates a new Technique.
func NewTechnique(technique_id string, name string) *Technique {
	return &Technique{
		proto: &taxonomypb.Technique{
			TechniqueId: technique_id,
			Name: name,
		},
	}
}

// NodeType implements GraphNode.
func (n *Technique) NodeType() string { return "technique" }

// Properties implements GraphNode.
func (n *Technique) Properties() map[string]any {
	props := make(map[string]any)
	props["technique_id"] = n.proto.TechniqueId
	props["name"] = n.proto.Name
	if n.proto.Taxonomy != nil {
		props["taxonomy"] = *n.proto.Taxonomy
	}
	if n.proto.Tactic != nil {
		props["tactic"] = *n.proto.Tactic
	}
	if n.proto.Description != nil {
		props["description"] = *n.proto.Description
	}
	if n.proto.Url != nil {
		props["url"] = *n.proto.Url
	}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *Technique) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
	props["technique_id"] = n.proto.TechniqueId
	return props
}

// ParentRef implements GraphNode.
func (n *Technique) ParentRef() *NodeRef {
	return nil
}

// Validate implements GraphNode.
func (n *Technique) Validate() error {
	return validation.ValidateTechnique(n.proto)
}

// ToProto implements GraphNode.
func (n *Technique) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "technique",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *Technique) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *Technique) SetID(id string) { n.proto.Id = id }

// --- Typed Accessors ---

// TechniqueId returns the technique_id value.
func (n *Technique) TechniqueId() string {
	return n.proto.TechniqueId
}

// SetTechniqueId sets the technique_id value.
func (n *Technique) SetTechniqueId(v string) *Technique {
	n.proto.TechniqueId = v
	return n
}

// Name returns the name value.
func (n *Technique) Name() string {
	return n.proto.Name
}

// SetName sets the name value.
func (n *Technique) SetName(v string) *Technique {
	n.proto.Name = v
	return n
}

// Taxonomy returns the taxonomy value.
func (n *Technique) Taxonomy() string {
	if n.proto.Taxonomy != nil {
		return *n.proto.Taxonomy
	}
	var zero string
	return zero
}

// SetTaxonomy sets the taxonomy value.
func (n *Technique) SetTaxonomy(v string) *Technique {
	n.proto.Taxonomy = &v
	return n
}

// Tactic returns the tactic value.
func (n *Technique) Tactic() string {
	if n.proto.Tactic != nil {
		return *n.proto.Tactic
	}
	var zero string
	return zero
}

// SetTactic sets the tactic value.
func (n *Technique) SetTactic(v string) *Technique {
	n.proto.Tactic = &v
	return n
}

// Description returns the description value.
func (n *Technique) Description() string {
	if n.proto.Description != nil {
		return *n.proto.Description
	}
	var zero string
	return zero
}

// SetDescription sets the description value.
func (n *Technique) SetDescription(v string) *Technique {
	n.proto.Description = &v
	return n
}

// Url returns the url value.
func (n *Technique) Url() string {
	if n.proto.Url != nil {
		return *n.proto.Url
	}
	var zero string
	return zero
}

// SetUrl sets the url value.
func (n *Technique) SetUrl(v string) *Technique {
	n.proto.Url = &v
	return n
}

