// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: taxonomy/core.yaml
// Taxonomy Version: 3.0.0
// Generated at: 2026-01-25T15:25:41Z
// Modified: Removed validators for types not in graphragpb

package validation

import (
	"fmt"
	"sync"

	"github.com/google/cel-go/cel"
	"github.com/zero-day-ai/sdk/api/gen/graphragpb"
)

var (
	initOnce sync.Once
	initErr  error

	// Pre-compiled CEL programs for each type
	domainValidators   []*compiledRule
	subdomainValidators []*compiledRule
	hostValidators     []*compiledRule
	portValidators     []*compiledRule
	serviceValidators  []*compiledRule
	endpointValidators []*compiledRule
	technologyValidators []*compiledRule
	certificateValidators []*compiledRule
	findingValidators  []*compiledRule
	evidenceValidators []*compiledRule

	// Core types set (only types that exist in graphragpb)
	coreTypes = map[string]bool{
		"domain":      true,
		"subdomain":   true,
		"host":        true,
		"port":        true,
		"service":     true,
		"endpoint":    true,
		"technology":  true,
		"certificate": true,
		"finding":     true,
		"evidence":    true,
	}

	// Parent requirements
	parentRequirements = map[string]ParentRequirement{
		"subdomain": {ParentType: "domain", Relationship: "HAS_SUBDOMAIN", Required: true},
		"port":      {ParentType: "host", Relationship: "HAS_PORT", Required: true},
		"service":   {ParentType: "port", Relationship: "RUNS_SERVICE", Required: true},
		"endpoint":  {ParentType: "service", Relationship: "HAS_ENDPOINT", Required: true},
		"evidence":  {ParentType: "finding", Relationship: "HAS_EVIDENCE", Required: true},
	}
)

type compiledRule struct {
	program cel.Program
	message string
}

// ParentRequirement defines the parent relationship for a node type.
type ParentRequirement struct {
	ParentType   string
	Relationship string
	Required     bool
}

func init() {
	initOnce.Do(func() {
		initErr = initValidators()
	})
}

func initValidators() error {
	// Initialize domain validators
	{
		env, err := cel.NewEnv(
			cel.Types(&graphragpb.Domain{}),
			cel.Variable("self", cel.ObjectType("gibson.graphrag.Domain")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for domain: %w", err)
		}
		domainValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.name) > 0", message: "domain name cannot be empty"},
		})
	}
	// Initialize subdomain validators
	{
		env, err := cel.NewEnv(
			cel.Types(&graphragpb.Subdomain{}),
			cel.Variable("self", cel.ObjectType("gibson.graphrag.Subdomain")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for subdomain: %w", err)
		}
		subdomainValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.name) > 0", message: "subdomain name cannot be empty"},
		})
	}
	// Initialize host validators
	{
		env, err := cel.NewEnv(
			cel.Types(&graphragpb.Host{}),
			cel.Variable("self", cel.ObjectType("gibson.graphrag.Host")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for host: %w", err)
		}
		hostValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.ip) > 0 || size(self.hostname) > 0", message: "host requires either ip or hostname"},
		})
	}
	// Initialize port validators
	{
		env, err := cel.NewEnv(
			cel.Types(&graphragpb.Port{}),
			cel.Variable("self", cel.ObjectType("gibson.graphrag.Port")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for port: %w", err)
		}
		portValidators = compileRules(env, []ruleSpec{
			{expr: "self.number >= 1 && self.number <= 65535", message: "port number must be between 1 and 65535"},
		})
	}
	// Initialize service validators (no specific rules)
	serviceValidators = []*compiledRule{}
	// Initialize endpoint validators
	{
		env, err := cel.NewEnv(
			cel.Types(&graphragpb.Endpoint{}),
			cel.Variable("self", cel.ObjectType("gibson.graphrag.Endpoint")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for endpoint: %w", err)
		}
		endpointValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.url) > 0", message: "endpoint URL cannot be empty"},
		})
	}
	// Initialize technology validators (no specific rules)
	technologyValidators = []*compiledRule{}
	// Initialize certificate validators (no specific rules)
	certificateValidators = []*compiledRule{}
	// Initialize finding validators
	{
		env, err := cel.NewEnv(
			cel.Types(&graphragpb.Finding{}),
			cel.Variable("self", cel.ObjectType("gibson.graphrag.Finding")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for finding: %w", err)
		}
		findingValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.title) > 0", message: "finding title cannot be empty"},
		})
	}
	// Initialize evidence validators (no specific rules)
	evidenceValidators = []*compiledRule{}

	return nil
}

type ruleSpec struct {
	expr    string
	message string
}

func compileRules(env *cel.Env, specs []ruleSpec) []*compiledRule {
	rules := make([]*compiledRule, 0, len(specs))
	for _, spec := range specs {
		ast, issues := env.Compile(spec.expr)
		if issues != nil && issues.Err() != nil {
			panic(fmt.Sprintf("failed to compile CEL rule '%s': %v", spec.expr, issues.Err()))
		}
		prg, err := env.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program for '%s': %v", spec.expr, err))
		}
		rules = append(rules, &compiledRule{program: prg, message: spec.message})
	}
	return rules
}

// ==================== PUBLIC API ====================

// IsCoreType returns true if the node type is a core (validated) type.
func IsCoreType(nodeType string) bool {
	return coreTypes[nodeType]
}

// GetParentRequirement returns the parent requirement for a node type.
func GetParentRequirement(nodeType string) (ParentRequirement, bool) {
	req, ok := parentRequirements[nodeType]
	return req, ok
}

// ValidateNode validates any node. Custom types pass through without validation.
func ValidateNode(nodeType string, properties map[string]any, hasParent bool) error {
	// Custom type - no validation
	if !IsCoreType(nodeType) {
		return nil
	}

	// Check parent requirement
	if req, ok := parentRequirements[nodeType]; ok && req.Required && !hasParent {
		return fmt.Errorf("%s requires a parent of type %s", nodeType, req.ParentType)
	}

	return nil
}

// ==================== TYPE-SPECIFIC VALIDATORS ====================

// ValidateDomain validates a Domain proto.
func ValidateDomain(p *graphragpb.Domain) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range domainValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("domain validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateSubdomain validates a Subdomain proto.
func ValidateSubdomain(p *graphragpb.Subdomain) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range subdomainValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("subdomain validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateHost validates a Host proto.
func ValidateHost(p *graphragpb.Host) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range hostValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("host validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidatePort validates a Port proto.
func ValidatePort(p *graphragpb.Port) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range portValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("port validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateService validates a Service proto.
func ValidateService(p *graphragpb.Service) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range serviceValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("service validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateEndpoint validates an Endpoint proto.
func ValidateEndpoint(p *graphragpb.Endpoint) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range endpointValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("endpoint validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateTechnology validates a Technology proto.
func ValidateTechnology(p *graphragpb.Technology) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range technologyValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("technology validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateCertificate validates a Certificate proto.
func ValidateCertificate(p *graphragpb.Certificate) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range certificateValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("certificate validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateFinding validates a Finding proto.
func ValidateFinding(p *graphragpb.Finding) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range findingValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("finding validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateEvidence validates an Evidence proto.
func ValidateEvidence(p *graphragpb.Evidence) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range evidenceValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("evidence validation failed: %s", rule.message)
		}
	}
	return nil
}
