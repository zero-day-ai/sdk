// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: taxonomy/core.yaml
// Taxonomy Version: 3.0.0
// Generated at: 2026-01-26T14:37:33Z

package validation

import (
	"fmt"
	"sync"

	"github.com/google/cel-go/cel"
	"github.com/zero-day-ai/sdk/api/gen/taxonomypb"
)

var (
	initOnce sync.Once
	initErr  error

	// Pre-compiled CEL programs for each type
	missionValidators  []*compiledRule
	domainValidators   []*compiledRule
	hostValidators     []*compiledRule
	portValidators     []*compiledRule
	endpointValidators []*compiledRule
	findingValidators  []*compiledRule

	// Core types set
	coreTypes = map[string]bool{
		"mission":        true,
		"mission_run":    true,
		"agent_run":      true,
		"tool_execution": true,
		"llm_call":       true,
		"domain":         true,
		"subdomain":      true,
		"host":           true,
		"port":           true,
		"service":        true,
		"endpoint":       true,
		"technology":     true,
		"certificate":    true,
		"finding":        true,
		"evidence":       true,
		"technique":      true,
	}

	// Parent requirements
	parentRequirements = map[string]ParentRequirement{
		"mission_run":    {ParentType: "mission", Relationship: "HAS_RUN", Required: true},
		"agent_run":      {ParentType: "mission_run", Relationship: "CONTAINS_AGENT_RUN", Required: true},
		"tool_execution": {ParentType: "agent_run", Relationship: "EXECUTED_TOOL", Required: true},
		"llm_call":       {ParentType: "agent_run", Relationship: "MADE_CALL", Required: true},
		"subdomain":      {ParentType: "domain", Relationship: "HAS_SUBDOMAIN", Required: true},
		"port":           {ParentType: "host", Relationship: "HAS_PORT", Required: true},
		"service":        {ParentType: "port", Relationship: "RUNS_SERVICE", Required: true},
		"endpoint":       {ParentType: "service", Relationship: "HAS_ENDPOINT", Required: true},
		"evidence":       {ParentType: "finding", Relationship: "HAS_EVIDENCE", Required: true},
	}
)

type compiledRule struct {
	program cel.Program
	message string
}

// ParentRequirement defines the parent relationship for a node type.
type ParentRequirement struct {
	ParentType   string
	Relationship string
	Required     bool
}

func init() {
	initOnce.Do(func() {
		initErr = initValidators()
	})
}

func initValidators() error {
	// Initialize mission validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.Mission{}),
			cel.Variable("self", cel.ObjectType("taxonomy.Mission")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for mission: %w", err)
		}
		missionValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.name) > 0", message: "mission name cannot be empty"},
			{expr: "size(self.target) > 0", message: "mission target cannot be empty"},
		})
	}
	// Initialize domain validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.Domain{}),
			cel.Variable("self", cel.ObjectType("taxonomy.Domain")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for domain: %w", err)
		}
		domainValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.name) > 0", message: "domain name cannot be empty"},
		})
	}
	// Initialize host validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.Host{}),
			cel.Variable("self", cel.ObjectType("taxonomy.Host")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for host: %w", err)
		}
		hostValidators = compileRules(env, []ruleSpec{
			{expr: "has(self.ip) || has(self.hostname)", message: "host requires either ip or hostname"},
		})
	}
	// Initialize port validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.Port{}),
			cel.Variable("self", cel.ObjectType("taxonomy.Port")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for port: %w", err)
		}
		portValidators = compileRules(env, []ruleSpec{
			{expr: "self.number >= 1 && self.number <= 65535", message: "port number must be between 1 and 65535"},
		})
	}
	// Initialize endpoint validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.Endpoint{}),
			cel.Variable("self", cel.ObjectType("taxonomy.Endpoint")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for endpoint: %w", err)
		}
		endpointValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.url) > 0", message: "endpoint URL cannot be empty"},
		})
	}
	// Initialize finding validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.Finding{}),
			cel.Variable("self", cel.ObjectType("taxonomy.Finding")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for finding: %w", err)
		}
		findingValidators = compileRules(env, []ruleSpec{
			{expr: "size(self.title) > 0", message: "finding title cannot be empty"},
			{expr: "!has(self.confidence) || (self.confidence >= 0.0 && self.confidence <= 1.0)", message: "confidence must be between 0.0 and 1.0"},
			{expr: "!has(self.cvss_score) || (self.cvss_score >= 0.0 && self.cvss_score <= 10.0)", message: "CVSS score must be between 0.0 and 10.0"},
		})
	}
	return nil
}

type ruleSpec struct {
	expr    string
	message string
}

func compileRules(env *cel.Env, specs []ruleSpec) []*compiledRule {
	rules := make([]*compiledRule, 0, len(specs))
	for _, spec := range specs {
		ast, issues := env.Compile(spec.expr)
		if issues != nil && issues.Err() != nil {
			panic(fmt.Sprintf("failed to compile CEL rule '%s': %v", spec.expr, issues.Err()))
		}
		prg, err := env.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program for '%s': %v", spec.expr, err))
		}
		rules = append(rules, &compiledRule{program: prg, message: spec.message})
	}
	return rules
}

// ==================== PUBLIC API ====================

// IsCoreType returns true if the node type is a core (validated) type.
func IsCoreType(nodeType string) bool {
	return coreTypes[nodeType]
}

// GetParentRequirement returns the parent requirement for a node type.
func GetParentRequirement(nodeType string) (ParentRequirement, bool) {
	req, ok := parentRequirements[nodeType]
	return req, ok
}

// ValidateNode validates any node. Custom types pass through without validation.
func ValidateNode(nodeType string, properties map[string]any, hasParent bool) error {
	// Custom type - no validation
	if !IsCoreType(nodeType) {
		return nil
	}

	// Check parent requirement
	if req, ok := parentRequirements[nodeType]; ok && req.Required && !hasParent {
		return fmt.Errorf("%s requires a parent of type %s", nodeType, req.ParentType)
	}

	return nil
}

// ==================== TYPE-SPECIFIC VALIDATORS ====================

// ValidateMission validates a Mission proto.
func ValidateMission(p *taxonomypb.Mission) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range missionValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("mission validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateMissionRun validates a MissionRun proto.
func ValidateMissionRun(p *taxonomypb.MissionRun) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateAgentRun validates a AgentRun proto.
func ValidateAgentRun(p *taxonomypb.AgentRun) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateToolExecution validates a ToolExecution proto.
func ValidateToolExecution(p *taxonomypb.ToolExecution) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateLlmCall validates a LlmCall proto.
func ValidateLlmCall(p *taxonomypb.LlmCall) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateDomain validates a Domain proto.
func ValidateDomain(p *taxonomypb.Domain) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range domainValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("domain validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateSubdomain validates a Subdomain proto.
func ValidateSubdomain(p *taxonomypb.Subdomain) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateHost validates a Host proto.
func ValidateHost(p *taxonomypb.Host) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range hostValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("host validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidatePort validates a Port proto.
func ValidatePort(p *taxonomypb.Port) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range portValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("port validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateService validates a Service proto.
func ValidateService(p *taxonomypb.Service) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateEndpoint validates a Endpoint proto.
func ValidateEndpoint(p *taxonomypb.Endpoint) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range endpointValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("endpoint validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateTechnology validates a Technology proto.
func ValidateTechnology(p *taxonomypb.Technology) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateCertificate validates a Certificate proto.
func ValidateCertificate(p *taxonomypb.Certificate) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateFinding validates a Finding proto.
func ValidateFinding(p *taxonomypb.Finding) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	for _, rule := range findingValidators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("finding validation failed: %s", rule.message)
		}
	}
	return nil
}

// ValidateEvidence validates a Evidence proto.
func ValidateEvidence(p *taxonomypb.Evidence) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}

// ValidateTechnique validates a Technique proto.
func ValidateTechnique(p *taxonomypb.Technique) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
	return nil
}
